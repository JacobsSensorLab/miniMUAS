// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages_2eproto;
namespace muas {
class Admin_Test_Request;
struct Admin_Test_RequestDefaultTypeInternal;
extern Admin_Test_RequestDefaultTypeInternal _Admin_Test_Request_default_instance_;
class Admin_Test_Response;
struct Admin_Test_ResponseDefaultTypeInternal;
extern Admin_Test_ResponseDefaultTypeInternal _Admin_Test_Response_default_instance_;
class Entity_Echo_Request;
struct Entity_Echo_RequestDefaultTypeInternal;
extern Entity_Echo_RequestDefaultTypeInternal _Entity_Echo_Request_default_instance_;
class Entity_Echo_Response;
struct Entity_Echo_ResponseDefaultTypeInternal;
extern Entity_Echo_ResponseDefaultTypeInternal _Entity_Echo_Response_default_instance_;
class Entity_GetEntityInfo_Request;
struct Entity_GetEntityInfo_RequestDefaultTypeInternal;
extern Entity_GetEntityInfo_RequestDefaultTypeInternal _Entity_GetEntityInfo_Request_default_instance_;
class Entity_GetEntityInfo_Response;
struct Entity_GetEntityInfo_ResponseDefaultTypeInternal;
extern Entity_GetEntityInfo_ResponseDefaultTypeInternal _Entity_GetEntityInfo_Response_default_instance_;
class Entity_GetOrientation_Request;
struct Entity_GetOrientation_RequestDefaultTypeInternal;
extern Entity_GetOrientation_RequestDefaultTypeInternal _Entity_GetOrientation_Request_default_instance_;
class Entity_GetOrientation_Response;
struct Entity_GetOrientation_ResponseDefaultTypeInternal;
extern Entity_GetOrientation_ResponseDefaultTypeInternal _Entity_GetOrientation_Response_default_instance_;
class Entity_GetPosition_Request;
struct Entity_GetPosition_RequestDefaultTypeInternal;
extern Entity_GetPosition_RequestDefaultTypeInternal _Entity_GetPosition_Request_default_instance_;
class Entity_GetPosition_Response;
struct Entity_GetPosition_ResponseDefaultTypeInternal;
extern Entity_GetPosition_ResponseDefaultTypeInternal _Entity_GetPosition_Response_default_instance_;
class FlightCtrl_Kill_Request;
struct FlightCtrl_Kill_RequestDefaultTypeInternal;
extern FlightCtrl_Kill_RequestDefaultTypeInternal _FlightCtrl_Kill_Request_default_instance_;
class FlightCtrl_Kill_Response;
struct FlightCtrl_Kill_ResponseDefaultTypeInternal;
extern FlightCtrl_Kill_ResponseDefaultTypeInternal _FlightCtrl_Kill_Response_default_instance_;
class FlightCtrl_Land_Request;
struct FlightCtrl_Land_RequestDefaultTypeInternal;
extern FlightCtrl_Land_RequestDefaultTypeInternal _FlightCtrl_Land_Request_default_instance_;
class FlightCtrl_Land_Response;
struct FlightCtrl_Land_ResponseDefaultTypeInternal;
extern FlightCtrl_Land_ResponseDefaultTypeInternal _FlightCtrl_Land_Response_default_instance_;
class FlightCtrl_RTL_Request;
struct FlightCtrl_RTL_RequestDefaultTypeInternal;
extern FlightCtrl_RTL_RequestDefaultTypeInternal _FlightCtrl_RTL_Request_default_instance_;
class FlightCtrl_RTL_Response;
struct FlightCtrl_RTL_ResponseDefaultTypeInternal;
extern FlightCtrl_RTL_ResponseDefaultTypeInternal _FlightCtrl_RTL_Response_default_instance_;
class FlightCtrl_Reposition_Request;
struct FlightCtrl_Reposition_RequestDefaultTypeInternal;
extern FlightCtrl_Reposition_RequestDefaultTypeInternal _FlightCtrl_Reposition_Request_default_instance_;
class FlightCtrl_Reposition_Response;
struct FlightCtrl_Reposition_ResponseDefaultTypeInternal;
extern FlightCtrl_Reposition_ResponseDefaultTypeInternal _FlightCtrl_Reposition_Response_default_instance_;
class FlightCtrl_SetSpeed_Request;
struct FlightCtrl_SetSpeed_RequestDefaultTypeInternal;
extern FlightCtrl_SetSpeed_RequestDefaultTypeInternal _FlightCtrl_SetSpeed_Request_default_instance_;
class FlightCtrl_SetSpeed_Response;
struct FlightCtrl_SetSpeed_ResponseDefaultTypeInternal;
extern FlightCtrl_SetSpeed_ResponseDefaultTypeInternal _FlightCtrl_SetSpeed_Response_default_instance_;
class FlightCtrl_SwitchMode_Request;
struct FlightCtrl_SwitchMode_RequestDefaultTypeInternal;
extern FlightCtrl_SwitchMode_RequestDefaultTypeInternal _FlightCtrl_SwitchMode_Request_default_instance_;
class FlightCtrl_SwitchMode_Response;
struct FlightCtrl_SwitchMode_ResponseDefaultTypeInternal;
extern FlightCtrl_SwitchMode_ResponseDefaultTypeInternal _FlightCtrl_SwitchMode_Response_default_instance_;
class FlightCtrl_Takeoff_Request;
struct FlightCtrl_Takeoff_RequestDefaultTypeInternal;
extern FlightCtrl_Takeoff_RequestDefaultTypeInternal _FlightCtrl_Takeoff_Request_default_instance_;
class FlightCtrl_Takeoff_Response;
struct FlightCtrl_Takeoff_ResponseDefaultTypeInternal;
extern FlightCtrl_Takeoff_ResponseDefaultTypeInternal _FlightCtrl_Takeoff_Response_default_instance_;
class IUAS_PointHover_Request;
struct IUAS_PointHover_RequestDefaultTypeInternal;
extern IUAS_PointHover_RequestDefaultTypeInternal _IUAS_PointHover_Request_default_instance_;
class IUAS_PointHover_Response;
struct IUAS_PointHover_ResponseDefaultTypeInternal;
extern IUAS_PointHover_ResponseDefaultTypeInternal _IUAS_PointHover_Response_default_instance_;
class IUAS_PointOrbit_Request;
struct IUAS_PointOrbit_RequestDefaultTypeInternal;
extern IUAS_PointOrbit_RequestDefaultTypeInternal _IUAS_PointOrbit_Request_default_instance_;
class IUAS_PointOrbit_Response;
struct IUAS_PointOrbit_ResponseDefaultTypeInternal;
extern IUAS_PointOrbit_ResponseDefaultTypeInternal _IUAS_PointOrbit_Response_default_instance_;
class MAVLink_Generic_Request;
struct MAVLink_Generic_RequestDefaultTypeInternal;
extern MAVLink_Generic_RequestDefaultTypeInternal _MAVLink_Generic_Request_default_instance_;
class MAVLink_Generic_Response;
struct MAVLink_Generic_ResponseDefaultTypeInternal;
extern MAVLink_Generic_ResponseDefaultTypeInternal _MAVLink_Generic_Response_default_instance_;
class MissionInfo;
struct MissionInfoDefaultTypeInternal;
extern MissionInfoDefaultTypeInternal _MissionInfo_default_instance_;
class MissionItem;
struct MissionItemDefaultTypeInternal;
extern MissionItemDefaultTypeInternal _MissionItem_default_instance_;
class Mission_Clear_Request;
struct Mission_Clear_RequestDefaultTypeInternal;
extern Mission_Clear_RequestDefaultTypeInternal _Mission_Clear_Request_default_instance_;
class Mission_Clear_Response;
struct Mission_Clear_ResponseDefaultTypeInternal;
extern Mission_Clear_ResponseDefaultTypeInternal _Mission_Clear_Response_default_instance_;
class Mission_Continue_Request;
struct Mission_Continue_RequestDefaultTypeInternal;
extern Mission_Continue_RequestDefaultTypeInternal _Mission_Continue_Request_default_instance_;
class Mission_Continue_Response;
struct Mission_Continue_ResponseDefaultTypeInternal;
extern Mission_Continue_ResponseDefaultTypeInternal _Mission_Continue_Response_default_instance_;
class Mission_GetItem_Request;
struct Mission_GetItem_RequestDefaultTypeInternal;
extern Mission_GetItem_RequestDefaultTypeInternal _Mission_GetItem_Request_default_instance_;
class Mission_GetItem_Response;
struct Mission_GetItem_ResponseDefaultTypeInternal;
extern Mission_GetItem_ResponseDefaultTypeInternal _Mission_GetItem_Response_default_instance_;
class Mission_GetMissionInfo_Request;
struct Mission_GetMissionInfo_RequestDefaultTypeInternal;
extern Mission_GetMissionInfo_RequestDefaultTypeInternal _Mission_GetMissionInfo_Request_default_instance_;
class Mission_GetMissionInfo_Response;
struct Mission_GetMissionInfo_ResponseDefaultTypeInternal;
extern Mission_GetMissionInfo_ResponseDefaultTypeInternal _Mission_GetMissionInfo_Response_default_instance_;
class Mission_Pause_Request;
struct Mission_Pause_RequestDefaultTypeInternal;
extern Mission_Pause_RequestDefaultTypeInternal _Mission_Pause_Request_default_instance_;
class Mission_Pause_Response;
struct Mission_Pause_ResponseDefaultTypeInternal;
extern Mission_Pause_ResponseDefaultTypeInternal _Mission_Pause_Response_default_instance_;
class Mission_SetItem_Request;
struct Mission_SetItem_RequestDefaultTypeInternal;
extern Mission_SetItem_RequestDefaultTypeInternal _Mission_SetItem_Request_default_instance_;
class Mission_SetItem_Response;
struct Mission_SetItem_ResponseDefaultTypeInternal;
extern Mission_SetItem_ResponseDefaultTypeInternal _Mission_SetItem_Response_default_instance_;
class Mission_Start_Request;
struct Mission_Start_RequestDefaultTypeInternal;
extern Mission_Start_RequestDefaultTypeInternal _Mission_Start_Request_default_instance_;
class Mission_Start_Response;
struct Mission_Start_ResponseDefaultTypeInternal;
extern Mission_Start_ResponseDefaultTypeInternal _Mission_Start_Response_default_instance_;
class Mission_Terminate_Request;
struct Mission_Terminate_RequestDefaultTypeInternal;
extern Mission_Terminate_RequestDefaultTypeInternal _Mission_Terminate_Request_default_instance_;
class Mission_Terminate_Response;
struct Mission_Terminate_ResponseDefaultTypeInternal;
extern Mission_Terminate_ResponseDefaultTypeInternal _Mission_Terminate_Response_default_instance_;
class NDNSF_Response;
struct NDNSF_ResponseDefaultTypeInternal;
extern NDNSF_ResponseDefaultTypeInternal _NDNSF_Response_default_instance_;
class Orientation;
struct OrientationDefaultTypeInternal;
extern OrientationDefaultTypeInternal _Orientation_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class Sensor;
struct SensorDefaultTypeInternal;
extern SensorDefaultTypeInternal _Sensor_default_instance_;
class SensorCtrl_CapturePeriodic_Request;
struct SensorCtrl_CapturePeriodic_RequestDefaultTypeInternal;
extern SensorCtrl_CapturePeriodic_RequestDefaultTypeInternal _SensorCtrl_CapturePeriodic_Request_default_instance_;
class SensorCtrl_CapturePeriodic_Response;
struct SensorCtrl_CapturePeriodic_ResponseDefaultTypeInternal;
extern SensorCtrl_CapturePeriodic_ResponseDefaultTypeInternal _SensorCtrl_CapturePeriodic_Response_default_instance_;
class SensorCtrl_CaptureSingle_Request;
struct SensorCtrl_CaptureSingle_RequestDefaultTypeInternal;
extern SensorCtrl_CaptureSingle_RequestDefaultTypeInternal _SensorCtrl_CaptureSingle_Request_default_instance_;
class SensorCtrl_CaptureSingle_Response;
struct SensorCtrl_CaptureSingle_ResponseDefaultTypeInternal;
extern SensorCtrl_CaptureSingle_ResponseDefaultTypeInternal _SensorCtrl_CaptureSingle_Response_default_instance_;
class SensorCtrl_GetSensorInfo_Request;
struct SensorCtrl_GetSensorInfo_RequestDefaultTypeInternal;
extern SensorCtrl_GetSensorInfo_RequestDefaultTypeInternal _SensorCtrl_GetSensorInfo_Request_default_instance_;
class SensorCtrl_GetSensorInfo_Response;
struct SensorCtrl_GetSensorInfo_ResponseDefaultTypeInternal;
extern SensorCtrl_GetSensorInfo_ResponseDefaultTypeInternal _SensorCtrl_GetSensorInfo_Response_default_instance_;
class WUAS_QuadRaster_Request;
struct WUAS_QuadRaster_RequestDefaultTypeInternal;
extern WUAS_QuadRaster_RequestDefaultTypeInternal _WUAS_QuadRaster_Request_default_instance_;
class WUAS_QuadRaster_Response;
struct WUAS_QuadRaster_ResponseDefaultTypeInternal;
extern WUAS_QuadRaster_ResponseDefaultTypeInternal _WUAS_QuadRaster_Response_default_instance_;
}  // namespace muas
PROTOBUF_NAMESPACE_OPEN
template<> ::muas::Admin_Test_Request* Arena::CreateMaybeMessage<::muas::Admin_Test_Request>(Arena*);
template<> ::muas::Admin_Test_Response* Arena::CreateMaybeMessage<::muas::Admin_Test_Response>(Arena*);
template<> ::muas::Entity_Echo_Request* Arena::CreateMaybeMessage<::muas::Entity_Echo_Request>(Arena*);
template<> ::muas::Entity_Echo_Response* Arena::CreateMaybeMessage<::muas::Entity_Echo_Response>(Arena*);
template<> ::muas::Entity_GetEntityInfo_Request* Arena::CreateMaybeMessage<::muas::Entity_GetEntityInfo_Request>(Arena*);
template<> ::muas::Entity_GetEntityInfo_Response* Arena::CreateMaybeMessage<::muas::Entity_GetEntityInfo_Response>(Arena*);
template<> ::muas::Entity_GetOrientation_Request* Arena::CreateMaybeMessage<::muas::Entity_GetOrientation_Request>(Arena*);
template<> ::muas::Entity_GetOrientation_Response* Arena::CreateMaybeMessage<::muas::Entity_GetOrientation_Response>(Arena*);
template<> ::muas::Entity_GetPosition_Request* Arena::CreateMaybeMessage<::muas::Entity_GetPosition_Request>(Arena*);
template<> ::muas::Entity_GetPosition_Response* Arena::CreateMaybeMessage<::muas::Entity_GetPosition_Response>(Arena*);
template<> ::muas::FlightCtrl_Kill_Request* Arena::CreateMaybeMessage<::muas::FlightCtrl_Kill_Request>(Arena*);
template<> ::muas::FlightCtrl_Kill_Response* Arena::CreateMaybeMessage<::muas::FlightCtrl_Kill_Response>(Arena*);
template<> ::muas::FlightCtrl_Land_Request* Arena::CreateMaybeMessage<::muas::FlightCtrl_Land_Request>(Arena*);
template<> ::muas::FlightCtrl_Land_Response* Arena::CreateMaybeMessage<::muas::FlightCtrl_Land_Response>(Arena*);
template<> ::muas::FlightCtrl_RTL_Request* Arena::CreateMaybeMessage<::muas::FlightCtrl_RTL_Request>(Arena*);
template<> ::muas::FlightCtrl_RTL_Response* Arena::CreateMaybeMessage<::muas::FlightCtrl_RTL_Response>(Arena*);
template<> ::muas::FlightCtrl_Reposition_Request* Arena::CreateMaybeMessage<::muas::FlightCtrl_Reposition_Request>(Arena*);
template<> ::muas::FlightCtrl_Reposition_Response* Arena::CreateMaybeMessage<::muas::FlightCtrl_Reposition_Response>(Arena*);
template<> ::muas::FlightCtrl_SetSpeed_Request* Arena::CreateMaybeMessage<::muas::FlightCtrl_SetSpeed_Request>(Arena*);
template<> ::muas::FlightCtrl_SetSpeed_Response* Arena::CreateMaybeMessage<::muas::FlightCtrl_SetSpeed_Response>(Arena*);
template<> ::muas::FlightCtrl_SwitchMode_Request* Arena::CreateMaybeMessage<::muas::FlightCtrl_SwitchMode_Request>(Arena*);
template<> ::muas::FlightCtrl_SwitchMode_Response* Arena::CreateMaybeMessage<::muas::FlightCtrl_SwitchMode_Response>(Arena*);
template<> ::muas::FlightCtrl_Takeoff_Request* Arena::CreateMaybeMessage<::muas::FlightCtrl_Takeoff_Request>(Arena*);
template<> ::muas::FlightCtrl_Takeoff_Response* Arena::CreateMaybeMessage<::muas::FlightCtrl_Takeoff_Response>(Arena*);
template<> ::muas::IUAS_PointHover_Request* Arena::CreateMaybeMessage<::muas::IUAS_PointHover_Request>(Arena*);
template<> ::muas::IUAS_PointHover_Response* Arena::CreateMaybeMessage<::muas::IUAS_PointHover_Response>(Arena*);
template<> ::muas::IUAS_PointOrbit_Request* Arena::CreateMaybeMessage<::muas::IUAS_PointOrbit_Request>(Arena*);
template<> ::muas::IUAS_PointOrbit_Response* Arena::CreateMaybeMessage<::muas::IUAS_PointOrbit_Response>(Arena*);
template<> ::muas::MAVLink_Generic_Request* Arena::CreateMaybeMessage<::muas::MAVLink_Generic_Request>(Arena*);
template<> ::muas::MAVLink_Generic_Response* Arena::CreateMaybeMessage<::muas::MAVLink_Generic_Response>(Arena*);
template<> ::muas::MissionInfo* Arena::CreateMaybeMessage<::muas::MissionInfo>(Arena*);
template<> ::muas::MissionItem* Arena::CreateMaybeMessage<::muas::MissionItem>(Arena*);
template<> ::muas::Mission_Clear_Request* Arena::CreateMaybeMessage<::muas::Mission_Clear_Request>(Arena*);
template<> ::muas::Mission_Clear_Response* Arena::CreateMaybeMessage<::muas::Mission_Clear_Response>(Arena*);
template<> ::muas::Mission_Continue_Request* Arena::CreateMaybeMessage<::muas::Mission_Continue_Request>(Arena*);
template<> ::muas::Mission_Continue_Response* Arena::CreateMaybeMessage<::muas::Mission_Continue_Response>(Arena*);
template<> ::muas::Mission_GetItem_Request* Arena::CreateMaybeMessage<::muas::Mission_GetItem_Request>(Arena*);
template<> ::muas::Mission_GetItem_Response* Arena::CreateMaybeMessage<::muas::Mission_GetItem_Response>(Arena*);
template<> ::muas::Mission_GetMissionInfo_Request* Arena::CreateMaybeMessage<::muas::Mission_GetMissionInfo_Request>(Arena*);
template<> ::muas::Mission_GetMissionInfo_Response* Arena::CreateMaybeMessage<::muas::Mission_GetMissionInfo_Response>(Arena*);
template<> ::muas::Mission_Pause_Request* Arena::CreateMaybeMessage<::muas::Mission_Pause_Request>(Arena*);
template<> ::muas::Mission_Pause_Response* Arena::CreateMaybeMessage<::muas::Mission_Pause_Response>(Arena*);
template<> ::muas::Mission_SetItem_Request* Arena::CreateMaybeMessage<::muas::Mission_SetItem_Request>(Arena*);
template<> ::muas::Mission_SetItem_Response* Arena::CreateMaybeMessage<::muas::Mission_SetItem_Response>(Arena*);
template<> ::muas::Mission_Start_Request* Arena::CreateMaybeMessage<::muas::Mission_Start_Request>(Arena*);
template<> ::muas::Mission_Start_Response* Arena::CreateMaybeMessage<::muas::Mission_Start_Response>(Arena*);
template<> ::muas::Mission_Terminate_Request* Arena::CreateMaybeMessage<::muas::Mission_Terminate_Request>(Arena*);
template<> ::muas::Mission_Terminate_Response* Arena::CreateMaybeMessage<::muas::Mission_Terminate_Response>(Arena*);
template<> ::muas::NDNSF_Response* Arena::CreateMaybeMessage<::muas::NDNSF_Response>(Arena*);
template<> ::muas::Orientation* Arena::CreateMaybeMessage<::muas::Orientation>(Arena*);
template<> ::muas::Position* Arena::CreateMaybeMessage<::muas::Position>(Arena*);
template<> ::muas::Sensor* Arena::CreateMaybeMessage<::muas::Sensor>(Arena*);
template<> ::muas::SensorCtrl_CapturePeriodic_Request* Arena::CreateMaybeMessage<::muas::SensorCtrl_CapturePeriodic_Request>(Arena*);
template<> ::muas::SensorCtrl_CapturePeriodic_Response* Arena::CreateMaybeMessage<::muas::SensorCtrl_CapturePeriodic_Response>(Arena*);
template<> ::muas::SensorCtrl_CaptureSingle_Request* Arena::CreateMaybeMessage<::muas::SensorCtrl_CaptureSingle_Request>(Arena*);
template<> ::muas::SensorCtrl_CaptureSingle_Response* Arena::CreateMaybeMessage<::muas::SensorCtrl_CaptureSingle_Response>(Arena*);
template<> ::muas::SensorCtrl_GetSensorInfo_Request* Arena::CreateMaybeMessage<::muas::SensorCtrl_GetSensorInfo_Request>(Arena*);
template<> ::muas::SensorCtrl_GetSensorInfo_Response* Arena::CreateMaybeMessage<::muas::SensorCtrl_GetSensorInfo_Response>(Arena*);
template<> ::muas::WUAS_QuadRaster_Request* Arena::CreateMaybeMessage<::muas::WUAS_QuadRaster_Request>(Arena*);
template<> ::muas::WUAS_QuadRaster_Response* Arena::CreateMaybeMessage<::muas::WUAS_QuadRaster_Response>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace muas {

enum MissionItem_Frame : int {
  MissionItem_Frame_UNKNOWN_FRAME = 0,
  MissionItem_Frame_GLOBAL = 1,
  MissionItem_Frame_RELATIVE_ALT = 2,
  MissionItem_Frame_TERRAIN_ALT = 3,
  MissionItem_Frame_INT = 4,
  MissionItem_Frame_MissionItem_Frame_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MissionItem_Frame_MissionItem_Frame_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MissionItem_Frame_IsValid(int value);
constexpr MissionItem_Frame MissionItem_Frame_Frame_MIN = MissionItem_Frame_UNKNOWN_FRAME;
constexpr MissionItem_Frame MissionItem_Frame_Frame_MAX = MissionItem_Frame_INT;
constexpr int MissionItem_Frame_Frame_ARRAYSIZE = MissionItem_Frame_Frame_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MissionItem_Frame_descriptor();
template<typename T>
inline const std::string& MissionItem_Frame_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MissionItem_Frame>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MissionItem_Frame_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MissionItem_Frame_descriptor(), enum_t_value);
}
inline bool MissionItem_Frame_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MissionItem_Frame* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MissionItem_Frame>(
    MissionItem_Frame_descriptor(), name, value);
}
enum MissionItem_MAV_CMD : int {
  MissionItem_MAV_CMD_UNKNOWN_CMD = 0,
  MissionItem_MAV_CMD_NAV_WAYPOINT = 1,
  MissionItem_MAV_CMD_NAV_RETURN_TO_LAUNCH = 2,
  MissionItem_MAV_CMD_NAV_LAND = 3,
  MissionItem_MAV_CMD_NAV_TAKEOFF = 4,
  MissionItem_MAV_CMD_NAV_LAND_LOCAL = 5,
  MissionItem_MAV_CMD_NAV_TAKEOFF_LOCAL = 6,
  MissionItem_MAV_CMD_DO_FOLLOW = 7,
  MissionItem_MAV_CMD_DO_FOLLOW_REPOSITION = 8,
  MissionItem_MAV_CMD_DO_ORBIT = 9,
  MissionItem_MAV_CMD_DO_FLIGHTTERMINATION = 10,
  MissionItem_MAV_CMD_DO_CHANGE_ALTITUDE = 11,
  MissionItem_MAV_CMD_DO_RETURN_PATH_START = 12,
  MissionItem_MAV_CMD_DO_LAND_START = 13,
  MissionItem_MAV_CMD_DO_RALLY_LAND = 14,
  MissionItem_MAV_CMD_DO_GO_AROUND = 15,
  MissionItem_MAV_CMD_DO_REPOSITION = 16,
  MissionItem_MAV_CMD_DO_PAUSE_CONTINUE = 17,
  MissionItem_MAV_CMD_MissionItem_MAV_CMD_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MissionItem_MAV_CMD_MissionItem_MAV_CMD_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MissionItem_MAV_CMD_IsValid(int value);
constexpr MissionItem_MAV_CMD MissionItem_MAV_CMD_MAV_CMD_MIN = MissionItem_MAV_CMD_UNKNOWN_CMD;
constexpr MissionItem_MAV_CMD MissionItem_MAV_CMD_MAV_CMD_MAX = MissionItem_MAV_CMD_DO_PAUSE_CONTINUE;
constexpr int MissionItem_MAV_CMD_MAV_CMD_ARRAYSIZE = MissionItem_MAV_CMD_MAV_CMD_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MissionItem_MAV_CMD_descriptor();
template<typename T>
inline const std::string& MissionItem_MAV_CMD_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MissionItem_MAV_CMD>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MissionItem_MAV_CMD_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MissionItem_MAV_CMD_descriptor(), enum_t_value);
}
inline bool MissionItem_MAV_CMD_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MissionItem_MAV_CMD* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MissionItem_MAV_CMD>(
    MissionItem_MAV_CMD_descriptor(), name, value);
}
enum Sensor_SensorType : int {
  Sensor_SensorType_UNKNOWN_SENSOR = 0,
  Sensor_SensorType_MULTISPECTRAL = 1,
  Sensor_SensorType_HYPERSPECTRAL = 2,
  Sensor_SensorType_ACOUSTIC = 3,
  Sensor_SensorType_MAGNETIC = 4,
  Sensor_SensorType_Sensor_SensorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Sensor_SensorType_Sensor_SensorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Sensor_SensorType_IsValid(int value);
constexpr Sensor_SensorType Sensor_SensorType_SensorType_MIN = Sensor_SensorType_UNKNOWN_SENSOR;
constexpr Sensor_SensorType Sensor_SensorType_SensorType_MAX = Sensor_SensorType_MAGNETIC;
constexpr int Sensor_SensorType_SensorType_ARRAYSIZE = Sensor_SensorType_SensorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Sensor_SensorType_descriptor();
template<typename T>
inline const std::string& Sensor_SensorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Sensor_SensorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Sensor_SensorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Sensor_SensorType_descriptor(), enum_t_value);
}
inline bool Sensor_SensorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Sensor_SensorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Sensor_SensorType>(
    Sensor_SensorType_descriptor(), name, value);
}
enum NDNSF_Response_miniMUAS_Code : int {
  NDNSF_Response_miniMUAS_Code_UNKNOWN_CODE = 0,
  NDNSF_Response_miniMUAS_Code_SUCCESS = 1,
  NDNSF_Response_miniMUAS_Code_ERROR = 2,
  NDNSF_Response_miniMUAS_Code_NDNSF_Response_miniMUAS_Code_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NDNSF_Response_miniMUAS_Code_NDNSF_Response_miniMUAS_Code_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NDNSF_Response_miniMUAS_Code_IsValid(int value);
constexpr NDNSF_Response_miniMUAS_Code NDNSF_Response_miniMUAS_Code_miniMUAS_Code_MIN = NDNSF_Response_miniMUAS_Code_UNKNOWN_CODE;
constexpr NDNSF_Response_miniMUAS_Code NDNSF_Response_miniMUAS_Code_miniMUAS_Code_MAX = NDNSF_Response_miniMUAS_Code_ERROR;
constexpr int NDNSF_Response_miniMUAS_Code_miniMUAS_Code_ARRAYSIZE = NDNSF_Response_miniMUAS_Code_miniMUAS_Code_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NDNSF_Response_miniMUAS_Code_descriptor();
template<typename T>
inline const std::string& NDNSF_Response_miniMUAS_Code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NDNSF_Response_miniMUAS_Code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NDNSF_Response_miniMUAS_Code_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NDNSF_Response_miniMUAS_Code_descriptor(), enum_t_value);
}
inline bool NDNSF_Response_miniMUAS_Code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NDNSF_Response_miniMUAS_Code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NDNSF_Response_miniMUAS_Code>(
    NDNSF_Response_miniMUAS_Code_descriptor(), name, value);
}
enum FlightCtrl_SwitchMode_Request_FlightMode : int {
  FlightCtrl_SwitchMode_Request_FlightMode_UNKNOWN = 0,
  FlightCtrl_SwitchMode_Request_FlightMode_STABILIZE = 1,
  FlightCtrl_SwitchMode_Request_FlightMode_ALT_HOLD = 2,
  FlightCtrl_SwitchMode_Request_FlightMode_LOITER = 3,
  FlightCtrl_SwitchMode_Request_FlightMode_GUIDED = 4,
  FlightCtrl_SwitchMode_Request_FlightMode_FlightCtrl_SwitchMode_Request_FlightMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FlightCtrl_SwitchMode_Request_FlightMode_FlightCtrl_SwitchMode_Request_FlightMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FlightCtrl_SwitchMode_Request_FlightMode_IsValid(int value);
constexpr FlightCtrl_SwitchMode_Request_FlightMode FlightCtrl_SwitchMode_Request_FlightMode_FlightMode_MIN = FlightCtrl_SwitchMode_Request_FlightMode_UNKNOWN;
constexpr FlightCtrl_SwitchMode_Request_FlightMode FlightCtrl_SwitchMode_Request_FlightMode_FlightMode_MAX = FlightCtrl_SwitchMode_Request_FlightMode_GUIDED;
constexpr int FlightCtrl_SwitchMode_Request_FlightMode_FlightMode_ARRAYSIZE = FlightCtrl_SwitchMode_Request_FlightMode_FlightMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FlightCtrl_SwitchMode_Request_FlightMode_descriptor();
template<typename T>
inline const std::string& FlightCtrl_SwitchMode_Request_FlightMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FlightCtrl_SwitchMode_Request_FlightMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FlightCtrl_SwitchMode_Request_FlightMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FlightCtrl_SwitchMode_Request_FlightMode_descriptor(), enum_t_value);
}
inline bool FlightCtrl_SwitchMode_Request_FlightMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FlightCtrl_SwitchMode_Request_FlightMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FlightCtrl_SwitchMode_Request_FlightMode>(
    FlightCtrl_SwitchMode_Request_FlightMode_descriptor(), name, value);
}
enum EntityType : int {
  ALL = 0,
  GCS = 1,
  UAS = 2,
  IUAS = 3,
  WUAS = 4,
  EntityType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EntityType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EntityType_IsValid(int value);
constexpr EntityType EntityType_MIN = ALL;
constexpr EntityType EntityType_MAX = WUAS;
constexpr int EntityType_ARRAYSIZE = EntityType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EntityType_descriptor();
template<typename T>
inline const std::string& EntityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EntityType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EntityType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EntityType_descriptor(), enum_t_value);
}
inline bool EntityType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EntityType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EntityType>(
    EntityType_descriptor(), name, value);
}
enum MAV_MSG : int {
  UNKNOWN_MSG = 0,
  HEARTBEAT = 1,
  SYS_STATUS = 2,
  SYSTEM_TIME = 3,
  GPS_RAW_INT = 4,
  GPS_STATUS = 5,
  SCALED_IMU = 6,
  RAW_IMU = 7,
  RAW_PRESSURE = 8,
  SCALED_PRESSURE = 9,
  ATTITUDE = 10,
  ATTITUDE_QUATERNION = 11,
  LOCAL_POSITION_NED = 12,
  GLOBAL_POSITION_INT = 13,
  MAV_MSG_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MAV_MSG_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MAV_MSG_IsValid(int value);
constexpr MAV_MSG MAV_MSG_MIN = UNKNOWN_MSG;
constexpr MAV_MSG MAV_MSG_MAX = GLOBAL_POSITION_INT;
constexpr int MAV_MSG_ARRAYSIZE = MAV_MSG_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MAV_MSG_descriptor();
template<typename T>
inline const std::string& MAV_MSG_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MAV_MSG>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MAV_MSG_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MAV_MSG_descriptor(), enum_t_value);
}
inline bool MAV_MSG_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MAV_MSG* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MAV_MSG>(
    MAV_MSG_descriptor(), name, value);
}
// ===================================================================

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
    kAltitudeFieldNumber = 3,
  };
  // float latitude = 1;
  void clear_latitude();
  float latitude() const;
  void set_latitude(float value);
  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);
  public:

  // float longitude = 2;
  void clear_longitude();
  float longitude() const;
  void set_longitude(float value);
  private:
  float _internal_longitude() const;
  void _internal_set_longitude(float value);
  public:

  // float altitude = 3;
  void clear_altitude();
  float altitude() const;
  void set_altitude(float value);
  private:
  float _internal_altitude() const;
  void _internal_set_altitude(float value);
  public:

  // @@protoc_insertion_point(class_scope:muas.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float latitude_;
    float longitude_;
    float altitude_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Orientation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Orientation) */ {
 public:
  inline Orientation() : Orientation(nullptr) {}
  ~Orientation() override;
  explicit PROTOBUF_CONSTEXPR Orientation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Orientation(const Orientation& from);
  Orientation(Orientation&& from) noexcept
    : Orientation() {
    *this = ::std::move(from);
  }

  inline Orientation& operator=(const Orientation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation& operator=(Orientation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation* internal_default_instance() {
    return reinterpret_cast<const Orientation*>(
               &_Orientation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Orientation& a, Orientation& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Orientation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Orientation& from) {
    Orientation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Orientation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Orientation";
  }
  protected:
  explicit Orientation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYawFieldNumber = 1,
    kPitchFieldNumber = 2,
    kRollFieldNumber = 3,
  };
  // float yaw = 1;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // float pitch = 2;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float roll = 3;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // @@protoc_insertion_point(class_scope:muas.Orientation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float yaw_;
    float pitch_;
    float roll_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class MissionItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.MissionItem) */ {
 public:
  inline MissionItem() : MissionItem(nullptr) {}
  ~MissionItem() override;
  explicit PROTOBUF_CONSTEXPR MissionItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MissionItem(const MissionItem& from);
  MissionItem(MissionItem&& from) noexcept
    : MissionItem() {
    *this = ::std::move(from);
  }

  inline MissionItem& operator=(const MissionItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline MissionItem& operator=(MissionItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MissionItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const MissionItem* internal_default_instance() {
    return reinterpret_cast<const MissionItem*>(
               &_MissionItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MissionItem& a, MissionItem& b) {
    a.Swap(&b);
  }
  inline void Swap(MissionItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MissionItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MissionItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MissionItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MissionItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MissionItem& from) {
    MissionItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MissionItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.MissionItem";
  }
  protected:
  explicit MissionItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MissionItem_Frame Frame;
  static constexpr Frame UNKNOWN_FRAME =
    MissionItem_Frame_UNKNOWN_FRAME;
  static constexpr Frame GLOBAL =
    MissionItem_Frame_GLOBAL;
  static constexpr Frame RELATIVE_ALT =
    MissionItem_Frame_RELATIVE_ALT;
  static constexpr Frame TERRAIN_ALT =
    MissionItem_Frame_TERRAIN_ALT;
  static constexpr Frame INT =
    MissionItem_Frame_INT;
  static inline bool Frame_IsValid(int value) {
    return MissionItem_Frame_IsValid(value);
  }
  static constexpr Frame Frame_MIN =
    MissionItem_Frame_Frame_MIN;
  static constexpr Frame Frame_MAX =
    MissionItem_Frame_Frame_MAX;
  static constexpr int Frame_ARRAYSIZE =
    MissionItem_Frame_Frame_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Frame_descriptor() {
    return MissionItem_Frame_descriptor();
  }
  template<typename T>
  static inline const std::string& Frame_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Frame>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Frame_Name.");
    return MissionItem_Frame_Name(enum_t_value);
  }
  static inline bool Frame_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Frame* value) {
    return MissionItem_Frame_Parse(name, value);
  }

  typedef MissionItem_MAV_CMD MAV_CMD;
  static constexpr MAV_CMD UNKNOWN_CMD =
    MissionItem_MAV_CMD_UNKNOWN_CMD;
  static constexpr MAV_CMD NAV_WAYPOINT =
    MissionItem_MAV_CMD_NAV_WAYPOINT;
  static constexpr MAV_CMD NAV_RETURN_TO_LAUNCH =
    MissionItem_MAV_CMD_NAV_RETURN_TO_LAUNCH;
  static constexpr MAV_CMD NAV_LAND =
    MissionItem_MAV_CMD_NAV_LAND;
  static constexpr MAV_CMD NAV_TAKEOFF =
    MissionItem_MAV_CMD_NAV_TAKEOFF;
  static constexpr MAV_CMD NAV_LAND_LOCAL =
    MissionItem_MAV_CMD_NAV_LAND_LOCAL;
  static constexpr MAV_CMD NAV_TAKEOFF_LOCAL =
    MissionItem_MAV_CMD_NAV_TAKEOFF_LOCAL;
  static constexpr MAV_CMD DO_FOLLOW =
    MissionItem_MAV_CMD_DO_FOLLOW;
  static constexpr MAV_CMD DO_FOLLOW_REPOSITION =
    MissionItem_MAV_CMD_DO_FOLLOW_REPOSITION;
  static constexpr MAV_CMD DO_ORBIT =
    MissionItem_MAV_CMD_DO_ORBIT;
  static constexpr MAV_CMD DO_FLIGHTTERMINATION =
    MissionItem_MAV_CMD_DO_FLIGHTTERMINATION;
  static constexpr MAV_CMD DO_CHANGE_ALTITUDE =
    MissionItem_MAV_CMD_DO_CHANGE_ALTITUDE;
  static constexpr MAV_CMD DO_RETURN_PATH_START =
    MissionItem_MAV_CMD_DO_RETURN_PATH_START;
  static constexpr MAV_CMD DO_LAND_START =
    MissionItem_MAV_CMD_DO_LAND_START;
  static constexpr MAV_CMD DO_RALLY_LAND =
    MissionItem_MAV_CMD_DO_RALLY_LAND;
  static constexpr MAV_CMD DO_GO_AROUND =
    MissionItem_MAV_CMD_DO_GO_AROUND;
  static constexpr MAV_CMD DO_REPOSITION =
    MissionItem_MAV_CMD_DO_REPOSITION;
  static constexpr MAV_CMD DO_PAUSE_CONTINUE =
    MissionItem_MAV_CMD_DO_PAUSE_CONTINUE;
  static inline bool MAV_CMD_IsValid(int value) {
    return MissionItem_MAV_CMD_IsValid(value);
  }
  static constexpr MAV_CMD MAV_CMD_MIN =
    MissionItem_MAV_CMD_MAV_CMD_MIN;
  static constexpr MAV_CMD MAV_CMD_MAX =
    MissionItem_MAV_CMD_MAV_CMD_MAX;
  static constexpr int MAV_CMD_ARRAYSIZE =
    MissionItem_MAV_CMD_MAV_CMD_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MAV_CMD_descriptor() {
    return MissionItem_MAV_CMD_descriptor();
  }
  template<typename T>
  static inline const std::string& MAV_CMD_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MAV_CMD>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MAV_CMD_Name.");
    return MissionItem_MAV_CMD_Name(enum_t_value);
  }
  static inline bool MAV_CMD_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MAV_CMD* value) {
    return MissionItem_MAV_CMD_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTargetSysFieldNumber = 1,
    kTargetCompFieldNumber = 2,
    kSeqFieldNumber = 3,
    kFrameFieldNumber = 4,
    kCmdFieldNumber = 5,
    kCurrentFieldNumber = 6,
    kAutocontinueFieldNumber = 7,
    kParam1FieldNumber = 8,
    kParam2FieldNumber = 9,
    kParam3FieldNumber = 10,
    kParam4FieldNumber = 11,
    kXFieldNumber = 12,
    kYFieldNumber = 13,
    kZFieldNumber = 14,
  };
  // int32 target_sys = 1;
  void clear_target_sys();
  int32_t target_sys() const;
  void set_target_sys(int32_t value);
  private:
  int32_t _internal_target_sys() const;
  void _internal_set_target_sys(int32_t value);
  public:

  // int32 target_comp = 2;
  void clear_target_comp();
  int32_t target_comp() const;
  void set_target_comp(int32_t value);
  private:
  int32_t _internal_target_comp() const;
  void _internal_set_target_comp(int32_t value);
  public:

  // int32 seq = 3;
  void clear_seq();
  int32_t seq() const;
  void set_seq(int32_t value);
  private:
  int32_t _internal_seq() const;
  void _internal_set_seq(int32_t value);
  public:

  // .muas.MissionItem.Frame frame = 4;
  void clear_frame();
  ::muas::MissionItem_Frame frame() const;
  void set_frame(::muas::MissionItem_Frame value);
  private:
  ::muas::MissionItem_Frame _internal_frame() const;
  void _internal_set_frame(::muas::MissionItem_Frame value);
  public:

  // .muas.MissionItem.MAV_CMD cmd = 5;
  void clear_cmd();
  ::muas::MissionItem_MAV_CMD cmd() const;
  void set_cmd(::muas::MissionItem_MAV_CMD value);
  private:
  ::muas::MissionItem_MAV_CMD _internal_cmd() const;
  void _internal_set_cmd(::muas::MissionItem_MAV_CMD value);
  public:

  // bool current = 6;
  void clear_current();
  bool current() const;
  void set_current(bool value);
  private:
  bool _internal_current() const;
  void _internal_set_current(bool value);
  public:

  // bool autocontinue = 7;
  void clear_autocontinue();
  bool autocontinue() const;
  void set_autocontinue(bool value);
  private:
  bool _internal_autocontinue() const;
  void _internal_set_autocontinue(bool value);
  public:

  // float param1 = 8;
  void clear_param1();
  float param1() const;
  void set_param1(float value);
  private:
  float _internal_param1() const;
  void _internal_set_param1(float value);
  public:

  // float param2 = 9;
  void clear_param2();
  float param2() const;
  void set_param2(float value);
  private:
  float _internal_param2() const;
  void _internal_set_param2(float value);
  public:

  // float param3 = 10;
  void clear_param3();
  float param3() const;
  void set_param3(float value);
  private:
  float _internal_param3() const;
  void _internal_set_param3(float value);
  public:

  // float param4 = 11;
  void clear_param4();
  float param4() const;
  void set_param4(float value);
  private:
  float _internal_param4() const;
  void _internal_set_param4(float value);
  public:

  // int32 x = 12;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 13;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // int32 z = 14;
  void clear_z();
  int32_t z() const;
  void set_z(int32_t value);
  private:
  int32_t _internal_z() const;
  void _internal_set_z(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:muas.MissionItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t target_sys_;
    int32_t target_comp_;
    int32_t seq_;
    int frame_;
    int cmd_;
    bool current_;
    bool autocontinue_;
    float param1_;
    float param2_;
    float param3_;
    float param4_;
    int32_t x_;
    int32_t y_;
    int32_t z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class MissionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.MissionInfo) */ {
 public:
  inline MissionInfo() : MissionInfo(nullptr) {}
  ~MissionInfo() override;
  explicit PROTOBUF_CONSTEXPR MissionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MissionInfo(const MissionInfo& from);
  MissionInfo(MissionInfo&& from) noexcept
    : MissionInfo() {
    *this = ::std::move(from);
  }

  inline MissionInfo& operator=(const MissionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MissionInfo& operator=(MissionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MissionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MissionInfo* internal_default_instance() {
    return reinterpret_cast<const MissionInfo*>(
               &_MissionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MissionInfo& a, MissionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MissionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MissionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MissionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MissionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MissionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MissionInfo& from) {
    MissionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MissionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.MissionInfo";
  }
  protected:
  explicit MissionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumItemsFieldNumber = 1,
  };
  // int32 num_items = 1;
  void clear_num_items();
  int32_t num_items() const;
  void set_num_items(int32_t value);
  private:
  int32_t _internal_num_items() const;
  void _internal_set_num_items(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:muas.MissionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t num_items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Sensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Sensor) */ {
 public:
  inline Sensor() : Sensor(nullptr) {}
  ~Sensor() override;
  explicit PROTOBUF_CONSTEXPR Sensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sensor(const Sensor& from);
  Sensor(Sensor&& from) noexcept
    : Sensor() {
    *this = ::std::move(from);
  }

  inline Sensor& operator=(const Sensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sensor& operator=(Sensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sensor* internal_default_instance() {
    return reinterpret_cast<const Sensor*>(
               &_Sensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Sensor& a, Sensor& b) {
    a.Swap(&b);
  }
  inline void Swap(Sensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sensor& from) {
    Sensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Sensor";
  }
  protected:
  explicit Sensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Sensor_SensorType SensorType;
  static constexpr SensorType UNKNOWN_SENSOR =
    Sensor_SensorType_UNKNOWN_SENSOR;
  static constexpr SensorType MULTISPECTRAL =
    Sensor_SensorType_MULTISPECTRAL;
  static constexpr SensorType HYPERSPECTRAL =
    Sensor_SensorType_HYPERSPECTRAL;
  static constexpr SensorType ACOUSTIC =
    Sensor_SensorType_ACOUSTIC;
  static constexpr SensorType MAGNETIC =
    Sensor_SensorType_MAGNETIC;
  static inline bool SensorType_IsValid(int value) {
    return Sensor_SensorType_IsValid(value);
  }
  static constexpr SensorType SensorType_MIN =
    Sensor_SensorType_SensorType_MIN;
  static constexpr SensorType SensorType_MAX =
    Sensor_SensorType_SensorType_MAX;
  static constexpr int SensorType_ARRAYSIZE =
    Sensor_SensorType_SensorType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SensorType_descriptor() {
    return Sensor_SensorType_descriptor();
  }
  template<typename T>
  static inline const std::string& SensorType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SensorType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SensorType_Name.");
    return Sensor_SensorType_Name(enum_t_value);
  }
  static inline bool SensorType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SensorType* value) {
    return Sensor_SensorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDataNamespaceFieldNumber = 4,
    kIdFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string data_namespace = 4;
  void clear_data_namespace();
  const std::string& data_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_namespace();
  PROTOBUF_NODISCARD std::string* release_data_namespace();
  void set_allocated_data_namespace(std::string* data_namespace);
  private:
  const std::string& _internal_data_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_namespace(const std::string& value);
  std::string* _internal_mutable_data_namespace();
  public:

  // int32 id = 2;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // .muas.Sensor.SensorType type = 3;
  void clear_type();
  ::muas::Sensor_SensorType type() const;
  void set_type(::muas::Sensor_SensorType value);
  private:
  ::muas::Sensor_SensorType _internal_type() const;
  void _internal_set_type(::muas::Sensor_SensorType value);
  public:

  // @@protoc_insertion_point(class_scope:muas.Sensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_namespace_;
    int32_t id_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class NDNSF_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.NDNSF_Response) */ {
 public:
  inline NDNSF_Response() : NDNSF_Response(nullptr) {}
  ~NDNSF_Response() override;
  explicit PROTOBUF_CONSTEXPR NDNSF_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NDNSF_Response(const NDNSF_Response& from);
  NDNSF_Response(NDNSF_Response&& from) noexcept
    : NDNSF_Response() {
    *this = ::std::move(from);
  }

  inline NDNSF_Response& operator=(const NDNSF_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline NDNSF_Response& operator=(NDNSF_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NDNSF_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const NDNSF_Response* internal_default_instance() {
    return reinterpret_cast<const NDNSF_Response*>(
               &_NDNSF_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NDNSF_Response& a, NDNSF_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(NDNSF_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NDNSF_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NDNSF_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NDNSF_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NDNSF_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NDNSF_Response& from) {
    NDNSF_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NDNSF_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.NDNSF_Response";
  }
  protected:
  explicit NDNSF_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NDNSF_Response_miniMUAS_Code miniMUAS_Code;
  static constexpr miniMUAS_Code UNKNOWN_CODE =
    NDNSF_Response_miniMUAS_Code_UNKNOWN_CODE;
  static constexpr miniMUAS_Code SUCCESS =
    NDNSF_Response_miniMUAS_Code_SUCCESS;
  static constexpr miniMUAS_Code ERROR =
    NDNSF_Response_miniMUAS_Code_ERROR;
  static inline bool miniMUAS_Code_IsValid(int value) {
    return NDNSF_Response_miniMUAS_Code_IsValid(value);
  }
  static constexpr miniMUAS_Code miniMUAS_Code_MIN =
    NDNSF_Response_miniMUAS_Code_miniMUAS_Code_MIN;
  static constexpr miniMUAS_Code miniMUAS_Code_MAX =
    NDNSF_Response_miniMUAS_Code_miniMUAS_Code_MAX;
  static constexpr int miniMUAS_Code_ARRAYSIZE =
    NDNSF_Response_miniMUAS_Code_miniMUAS_Code_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  miniMUAS_Code_descriptor() {
    return NDNSF_Response_miniMUAS_Code_descriptor();
  }
  template<typename T>
  static inline const std::string& miniMUAS_Code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, miniMUAS_Code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function miniMUAS_Code_Name.");
    return NDNSF_Response_miniMUAS_Code_Name(enum_t_value);
  }
  static inline bool miniMUAS_Code_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      miniMUAS_Code* value) {
    return NDNSF_Response_miniMUAS_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // optional string msg = 2;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // .muas.NDNSF_Response.miniMUAS_Code code = 1;
  void clear_code();
  ::muas::NDNSF_Response_miniMUAS_Code code() const;
  void set_code(::muas::NDNSF_Response_miniMUAS_Code value);
  private:
  ::muas::NDNSF_Response_miniMUAS_Code _internal_code() const;
  void _internal_set_code(::muas::NDNSF_Response_miniMUAS_Code value);
  public:

  // @@protoc_insertion_point(class_scope:muas.NDNSF_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    int code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Entity_Echo_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Entity_Echo_Request) */ {
 public:
  inline Entity_Echo_Request() : Entity_Echo_Request(nullptr) {}
  ~Entity_Echo_Request() override;
  explicit PROTOBUF_CONSTEXPR Entity_Echo_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entity_Echo_Request(const Entity_Echo_Request& from);
  Entity_Echo_Request(Entity_Echo_Request&& from) noexcept
    : Entity_Echo_Request() {
    *this = ::std::move(from);
  }

  inline Entity_Echo_Request& operator=(const Entity_Echo_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entity_Echo_Request& operator=(Entity_Echo_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entity_Echo_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entity_Echo_Request* internal_default_instance() {
    return reinterpret_cast<const Entity_Echo_Request*>(
               &_Entity_Echo_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Entity_Echo_Request& a, Entity_Echo_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Entity_Echo_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entity_Echo_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entity_Echo_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Entity_Echo_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Entity_Echo_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Entity_Echo_Request& from) {
    Entity_Echo_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entity_Echo_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Entity_Echo_Request";
  }
  protected:
  explicit Entity_Echo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
  };
  // string nonce = 1;
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // @@protoc_insertion_point(class_scope:muas.Entity_Echo_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Entity_Echo_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Entity_Echo_Response) */ {
 public:
  inline Entity_Echo_Response() : Entity_Echo_Response(nullptr) {}
  ~Entity_Echo_Response() override;
  explicit PROTOBUF_CONSTEXPR Entity_Echo_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entity_Echo_Response(const Entity_Echo_Response& from);
  Entity_Echo_Response(Entity_Echo_Response&& from) noexcept
    : Entity_Echo_Response() {
    *this = ::std::move(from);
  }

  inline Entity_Echo_Response& operator=(const Entity_Echo_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entity_Echo_Response& operator=(Entity_Echo_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entity_Echo_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entity_Echo_Response* internal_default_instance() {
    return reinterpret_cast<const Entity_Echo_Response*>(
               &_Entity_Echo_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Entity_Echo_Response& a, Entity_Echo_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Entity_Echo_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entity_Echo_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entity_Echo_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Entity_Echo_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Entity_Echo_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Entity_Echo_Response& from) {
    Entity_Echo_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entity_Echo_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Entity_Echo_Response";
  }
  protected:
  explicit Entity_Echo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
  };
  // string nonce = 1;
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // @@protoc_insertion_point(class_scope:muas.Entity_Echo_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Entity_GetEntityInfo_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Entity_GetEntityInfo_Request) */ {
 public:
  inline Entity_GetEntityInfo_Request() : Entity_GetEntityInfo_Request(nullptr) {}
  ~Entity_GetEntityInfo_Request() override;
  explicit PROTOBUF_CONSTEXPR Entity_GetEntityInfo_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entity_GetEntityInfo_Request(const Entity_GetEntityInfo_Request& from);
  Entity_GetEntityInfo_Request(Entity_GetEntityInfo_Request&& from) noexcept
    : Entity_GetEntityInfo_Request() {
    *this = ::std::move(from);
  }

  inline Entity_GetEntityInfo_Request& operator=(const Entity_GetEntityInfo_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entity_GetEntityInfo_Request& operator=(Entity_GetEntityInfo_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entity_GetEntityInfo_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entity_GetEntityInfo_Request* internal_default_instance() {
    return reinterpret_cast<const Entity_GetEntityInfo_Request*>(
               &_Entity_GetEntityInfo_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Entity_GetEntityInfo_Request& a, Entity_GetEntityInfo_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Entity_GetEntityInfo_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entity_GetEntityInfo_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entity_GetEntityInfo_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Entity_GetEntityInfo_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Entity_GetEntityInfo_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Entity_GetEntityInfo_Request& from) {
    Entity_GetEntityInfo_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entity_GetEntityInfo_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Entity_GetEntityInfo_Request";
  }
  protected:
  explicit Entity_GetEntityInfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // int32 key = 2;
  void clear_key();
  int32_t key() const;
  void set_key(int32_t value);
  private:
  int32_t _internal_key() const;
  void _internal_set_key(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:muas.Entity_GetEntityInfo_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    int32_t key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Entity_GetEntityInfo_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Entity_GetEntityInfo_Response) */ {
 public:
  inline Entity_GetEntityInfo_Response() : Entity_GetEntityInfo_Response(nullptr) {}
  ~Entity_GetEntityInfo_Response() override;
  explicit PROTOBUF_CONSTEXPR Entity_GetEntityInfo_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entity_GetEntityInfo_Response(const Entity_GetEntityInfo_Response& from);
  Entity_GetEntityInfo_Response(Entity_GetEntityInfo_Response&& from) noexcept
    : Entity_GetEntityInfo_Response() {
    *this = ::std::move(from);
  }

  inline Entity_GetEntityInfo_Response& operator=(const Entity_GetEntityInfo_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entity_GetEntityInfo_Response& operator=(Entity_GetEntityInfo_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entity_GetEntityInfo_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entity_GetEntityInfo_Response* internal_default_instance() {
    return reinterpret_cast<const Entity_GetEntityInfo_Response*>(
               &_Entity_GetEntityInfo_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Entity_GetEntityInfo_Response& a, Entity_GetEntityInfo_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Entity_GetEntityInfo_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entity_GetEntityInfo_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entity_GetEntityInfo_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Entity_GetEntityInfo_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Entity_GetEntityInfo_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Entity_GetEntityInfo_Response& from) {
    Entity_GetEntityInfo_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entity_GetEntityInfo_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Entity_GetEntityInfo_Response";
  }
  protected:
  explicit Entity_GetEntityInfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kResponseFieldNumber = 1,
  };
  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.Entity_GetEntityInfo_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Entity_GetPosition_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.Entity_GetPosition_Request) */ {
 public:
  inline Entity_GetPosition_Request() : Entity_GetPosition_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Entity_GetPosition_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entity_GetPosition_Request(const Entity_GetPosition_Request& from);
  Entity_GetPosition_Request(Entity_GetPosition_Request&& from) noexcept
    : Entity_GetPosition_Request() {
    *this = ::std::move(from);
  }

  inline Entity_GetPosition_Request& operator=(const Entity_GetPosition_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entity_GetPosition_Request& operator=(Entity_GetPosition_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entity_GetPosition_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entity_GetPosition_Request* internal_default_instance() {
    return reinterpret_cast<const Entity_GetPosition_Request*>(
               &_Entity_GetPosition_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Entity_GetPosition_Request& a, Entity_GetPosition_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Entity_GetPosition_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entity_GetPosition_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entity_GetPosition_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Entity_GetPosition_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Entity_GetPosition_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Entity_GetPosition_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Entity_GetPosition_Request";
  }
  protected:
  explicit Entity_GetPosition_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.Entity_GetPosition_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Entity_GetPosition_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Entity_GetPosition_Response) */ {
 public:
  inline Entity_GetPosition_Response() : Entity_GetPosition_Response(nullptr) {}
  ~Entity_GetPosition_Response() override;
  explicit PROTOBUF_CONSTEXPR Entity_GetPosition_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entity_GetPosition_Response(const Entity_GetPosition_Response& from);
  Entity_GetPosition_Response(Entity_GetPosition_Response&& from) noexcept
    : Entity_GetPosition_Response() {
    *this = ::std::move(from);
  }

  inline Entity_GetPosition_Response& operator=(const Entity_GetPosition_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entity_GetPosition_Response& operator=(Entity_GetPosition_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entity_GetPosition_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entity_GetPosition_Response* internal_default_instance() {
    return reinterpret_cast<const Entity_GetPosition_Response*>(
               &_Entity_GetPosition_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Entity_GetPosition_Response& a, Entity_GetPosition_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Entity_GetPosition_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entity_GetPosition_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entity_GetPosition_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Entity_GetPosition_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Entity_GetPosition_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Entity_GetPosition_Response& from) {
    Entity_GetPosition_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entity_GetPosition_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Entity_GetPosition_Response";
  }
  protected:
  explicit Entity_GetPosition_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kPosFieldNumber = 2,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // .muas.Position pos = 2;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::muas::Position& pos() const;
  PROTOBUF_NODISCARD ::muas::Position* release_pos();
  ::muas::Position* mutable_pos();
  void set_allocated_pos(::muas::Position* pos);
  private:
  const ::muas::Position& _internal_pos() const;
  ::muas::Position* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::muas::Position* pos);
  ::muas::Position* unsafe_arena_release_pos();

  // @@protoc_insertion_point(class_scope:muas.Entity_GetPosition_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    ::muas::Position* pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Entity_GetOrientation_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.Entity_GetOrientation_Request) */ {
 public:
  inline Entity_GetOrientation_Request() : Entity_GetOrientation_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Entity_GetOrientation_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entity_GetOrientation_Request(const Entity_GetOrientation_Request& from);
  Entity_GetOrientation_Request(Entity_GetOrientation_Request&& from) noexcept
    : Entity_GetOrientation_Request() {
    *this = ::std::move(from);
  }

  inline Entity_GetOrientation_Request& operator=(const Entity_GetOrientation_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entity_GetOrientation_Request& operator=(Entity_GetOrientation_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entity_GetOrientation_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entity_GetOrientation_Request* internal_default_instance() {
    return reinterpret_cast<const Entity_GetOrientation_Request*>(
               &_Entity_GetOrientation_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Entity_GetOrientation_Request& a, Entity_GetOrientation_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Entity_GetOrientation_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entity_GetOrientation_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entity_GetOrientation_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Entity_GetOrientation_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Entity_GetOrientation_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Entity_GetOrientation_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Entity_GetOrientation_Request";
  }
  protected:
  explicit Entity_GetOrientation_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.Entity_GetOrientation_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Entity_GetOrientation_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Entity_GetOrientation_Response) */ {
 public:
  inline Entity_GetOrientation_Response() : Entity_GetOrientation_Response(nullptr) {}
  ~Entity_GetOrientation_Response() override;
  explicit PROTOBUF_CONSTEXPR Entity_GetOrientation_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entity_GetOrientation_Response(const Entity_GetOrientation_Response& from);
  Entity_GetOrientation_Response(Entity_GetOrientation_Response&& from) noexcept
    : Entity_GetOrientation_Response() {
    *this = ::std::move(from);
  }

  inline Entity_GetOrientation_Response& operator=(const Entity_GetOrientation_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entity_GetOrientation_Response& operator=(Entity_GetOrientation_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entity_GetOrientation_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entity_GetOrientation_Response* internal_default_instance() {
    return reinterpret_cast<const Entity_GetOrientation_Response*>(
               &_Entity_GetOrientation_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Entity_GetOrientation_Response& a, Entity_GetOrientation_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Entity_GetOrientation_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entity_GetOrientation_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entity_GetOrientation_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Entity_GetOrientation_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Entity_GetOrientation_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Entity_GetOrientation_Response& from) {
    Entity_GetOrientation_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entity_GetOrientation_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Entity_GetOrientation_Response";
  }
  protected:
  explicit Entity_GetOrientation_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kAttitudeFieldNumber = 2,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // .muas.Orientation attitude = 2;
  bool has_attitude() const;
  private:
  bool _internal_has_attitude() const;
  public:
  void clear_attitude();
  const ::muas::Orientation& attitude() const;
  PROTOBUF_NODISCARD ::muas::Orientation* release_attitude();
  ::muas::Orientation* mutable_attitude();
  void set_allocated_attitude(::muas::Orientation* attitude);
  private:
  const ::muas::Orientation& _internal_attitude() const;
  ::muas::Orientation* _internal_mutable_attitude();
  public:
  void unsafe_arena_set_allocated_attitude(
      ::muas::Orientation* attitude);
  ::muas::Orientation* unsafe_arena_release_attitude();

  // @@protoc_insertion_point(class_scope:muas.Entity_GetOrientation_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    ::muas::Orientation* attitude_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Admin_Test_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.Admin_Test_Request) */ {
 public:
  inline Admin_Test_Request() : Admin_Test_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Admin_Test_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Admin_Test_Request(const Admin_Test_Request& from);
  Admin_Test_Request(Admin_Test_Request&& from) noexcept
    : Admin_Test_Request() {
    *this = ::std::move(from);
  }

  inline Admin_Test_Request& operator=(const Admin_Test_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Admin_Test_Request& operator=(Admin_Test_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Admin_Test_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Admin_Test_Request* internal_default_instance() {
    return reinterpret_cast<const Admin_Test_Request*>(
               &_Admin_Test_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Admin_Test_Request& a, Admin_Test_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Admin_Test_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Admin_Test_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Admin_Test_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Admin_Test_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Admin_Test_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Admin_Test_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Admin_Test_Request";
  }
  protected:
  explicit Admin_Test_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.Admin_Test_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Admin_Test_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Admin_Test_Response) */ {
 public:
  inline Admin_Test_Response() : Admin_Test_Response(nullptr) {}
  ~Admin_Test_Response() override;
  explicit PROTOBUF_CONSTEXPR Admin_Test_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Admin_Test_Response(const Admin_Test_Response& from);
  Admin_Test_Response(Admin_Test_Response&& from) noexcept
    : Admin_Test_Response() {
    *this = ::std::move(from);
  }

  inline Admin_Test_Response& operator=(const Admin_Test_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Admin_Test_Response& operator=(Admin_Test_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Admin_Test_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Admin_Test_Response* internal_default_instance() {
    return reinterpret_cast<const Admin_Test_Response*>(
               &_Admin_Test_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Admin_Test_Response& a, Admin_Test_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Admin_Test_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Admin_Test_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Admin_Test_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Admin_Test_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Admin_Test_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Admin_Test_Response& from) {
    Admin_Test_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Admin_Test_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Admin_Test_Response";
  }
  protected:
  explicit Admin_Test_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplyFieldNumber = 2,
    kResponseFieldNumber = 1,
  };
  // string reply = 2;
  void clear_reply();
  const std::string& reply() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply();
  PROTOBUF_NODISCARD std::string* release_reply();
  void set_allocated_reply(std::string* reply);
  private:
  const std::string& _internal_reply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply(const std::string& value);
  std::string* _internal_mutable_reply();
  public:

  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.Admin_Test_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_;
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class WUAS_QuadRaster_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.WUAS_QuadRaster_Request) */ {
 public:
  inline WUAS_QuadRaster_Request() : WUAS_QuadRaster_Request(nullptr) {}
  ~WUAS_QuadRaster_Request() override;
  explicit PROTOBUF_CONSTEXPR WUAS_QuadRaster_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WUAS_QuadRaster_Request(const WUAS_QuadRaster_Request& from);
  WUAS_QuadRaster_Request(WUAS_QuadRaster_Request&& from) noexcept
    : WUAS_QuadRaster_Request() {
    *this = ::std::move(from);
  }

  inline WUAS_QuadRaster_Request& operator=(const WUAS_QuadRaster_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline WUAS_QuadRaster_Request& operator=(WUAS_QuadRaster_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WUAS_QuadRaster_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const WUAS_QuadRaster_Request* internal_default_instance() {
    return reinterpret_cast<const WUAS_QuadRaster_Request*>(
               &_WUAS_QuadRaster_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(WUAS_QuadRaster_Request& a, WUAS_QuadRaster_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(WUAS_QuadRaster_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WUAS_QuadRaster_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WUAS_QuadRaster_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WUAS_QuadRaster_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WUAS_QuadRaster_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WUAS_QuadRaster_Request& from) {
    WUAS_QuadRaster_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WUAS_QuadRaster_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.WUAS_QuadRaster_Request";
  }
  protected:
  explicit WUAS_QuadRaster_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNwCoordFieldNumber = 1,
    kSeCoordFieldNumber = 2,
    kAltFieldNumber = 3,
    kPassesFieldNumber = 4,
  };
  // .muas.Position nw_coord = 1;
  bool has_nw_coord() const;
  private:
  bool _internal_has_nw_coord() const;
  public:
  void clear_nw_coord();
  const ::muas::Position& nw_coord() const;
  PROTOBUF_NODISCARD ::muas::Position* release_nw_coord();
  ::muas::Position* mutable_nw_coord();
  void set_allocated_nw_coord(::muas::Position* nw_coord);
  private:
  const ::muas::Position& _internal_nw_coord() const;
  ::muas::Position* _internal_mutable_nw_coord();
  public:
  void unsafe_arena_set_allocated_nw_coord(
      ::muas::Position* nw_coord);
  ::muas::Position* unsafe_arena_release_nw_coord();

  // .muas.Position se_coord = 2;
  bool has_se_coord() const;
  private:
  bool _internal_has_se_coord() const;
  public:
  void clear_se_coord();
  const ::muas::Position& se_coord() const;
  PROTOBUF_NODISCARD ::muas::Position* release_se_coord();
  ::muas::Position* mutable_se_coord();
  void set_allocated_se_coord(::muas::Position* se_coord);
  private:
  const ::muas::Position& _internal_se_coord() const;
  ::muas::Position* _internal_mutable_se_coord();
  public:
  void unsafe_arena_set_allocated_se_coord(
      ::muas::Position* se_coord);
  ::muas::Position* unsafe_arena_release_se_coord();

  // float alt = 3;
  void clear_alt();
  float alt() const;
  void set_alt(float value);
  private:
  float _internal_alt() const;
  void _internal_set_alt(float value);
  public:

  // int32 passes = 4;
  void clear_passes();
  int32_t passes() const;
  void set_passes(int32_t value);
  private:
  int32_t _internal_passes() const;
  void _internal_set_passes(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:muas.WUAS_QuadRaster_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::Position* nw_coord_;
    ::muas::Position* se_coord_;
    float alt_;
    int32_t passes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class WUAS_QuadRaster_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.WUAS_QuadRaster_Response) */ {
 public:
  inline WUAS_QuadRaster_Response() : WUAS_QuadRaster_Response(nullptr) {}
  ~WUAS_QuadRaster_Response() override;
  explicit PROTOBUF_CONSTEXPR WUAS_QuadRaster_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WUAS_QuadRaster_Response(const WUAS_QuadRaster_Response& from);
  WUAS_QuadRaster_Response(WUAS_QuadRaster_Response&& from) noexcept
    : WUAS_QuadRaster_Response() {
    *this = ::std::move(from);
  }

  inline WUAS_QuadRaster_Response& operator=(const WUAS_QuadRaster_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline WUAS_QuadRaster_Response& operator=(WUAS_QuadRaster_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WUAS_QuadRaster_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const WUAS_QuadRaster_Response* internal_default_instance() {
    return reinterpret_cast<const WUAS_QuadRaster_Response*>(
               &_WUAS_QuadRaster_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WUAS_QuadRaster_Response& a, WUAS_QuadRaster_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(WUAS_QuadRaster_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WUAS_QuadRaster_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WUAS_QuadRaster_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WUAS_QuadRaster_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WUAS_QuadRaster_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WUAS_QuadRaster_Response& from) {
    WUAS_QuadRaster_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WUAS_QuadRaster_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.WUAS_QuadRaster_Response";
  }
  protected:
  explicit WUAS_QuadRaster_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.WUAS_QuadRaster_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class IUAS_PointOrbit_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.IUAS_PointOrbit_Request) */ {
 public:
  inline IUAS_PointOrbit_Request() : IUAS_PointOrbit_Request(nullptr) {}
  ~IUAS_PointOrbit_Request() override;
  explicit PROTOBUF_CONSTEXPR IUAS_PointOrbit_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IUAS_PointOrbit_Request(const IUAS_PointOrbit_Request& from);
  IUAS_PointOrbit_Request(IUAS_PointOrbit_Request&& from) noexcept
    : IUAS_PointOrbit_Request() {
    *this = ::std::move(from);
  }

  inline IUAS_PointOrbit_Request& operator=(const IUAS_PointOrbit_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline IUAS_PointOrbit_Request& operator=(IUAS_PointOrbit_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IUAS_PointOrbit_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const IUAS_PointOrbit_Request* internal_default_instance() {
    return reinterpret_cast<const IUAS_PointOrbit_Request*>(
               &_IUAS_PointOrbit_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(IUAS_PointOrbit_Request& a, IUAS_PointOrbit_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(IUAS_PointOrbit_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IUAS_PointOrbit_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IUAS_PointOrbit_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IUAS_PointOrbit_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IUAS_PointOrbit_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IUAS_PointOrbit_Request& from) {
    IUAS_PointOrbit_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IUAS_PointOrbit_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.IUAS_PointOrbit_Request";
  }
  protected:
  explicit IUAS_PointOrbit_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetFieldNumber = 1,
  };
  // .muas.Position target = 1;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::muas::Position& target() const;
  PROTOBUF_NODISCARD ::muas::Position* release_target();
  ::muas::Position* mutable_target();
  void set_allocated_target(::muas::Position* target);
  private:
  const ::muas::Position& _internal_target() const;
  ::muas::Position* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::muas::Position* target);
  ::muas::Position* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:muas.IUAS_PointOrbit_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::Position* target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class IUAS_PointOrbit_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.IUAS_PointOrbit_Response) */ {
 public:
  inline IUAS_PointOrbit_Response() : IUAS_PointOrbit_Response(nullptr) {}
  ~IUAS_PointOrbit_Response() override;
  explicit PROTOBUF_CONSTEXPR IUAS_PointOrbit_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IUAS_PointOrbit_Response(const IUAS_PointOrbit_Response& from);
  IUAS_PointOrbit_Response(IUAS_PointOrbit_Response&& from) noexcept
    : IUAS_PointOrbit_Response() {
    *this = ::std::move(from);
  }

  inline IUAS_PointOrbit_Response& operator=(const IUAS_PointOrbit_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline IUAS_PointOrbit_Response& operator=(IUAS_PointOrbit_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IUAS_PointOrbit_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const IUAS_PointOrbit_Response* internal_default_instance() {
    return reinterpret_cast<const IUAS_PointOrbit_Response*>(
               &_IUAS_PointOrbit_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(IUAS_PointOrbit_Response& a, IUAS_PointOrbit_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(IUAS_PointOrbit_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IUAS_PointOrbit_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IUAS_PointOrbit_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IUAS_PointOrbit_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IUAS_PointOrbit_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IUAS_PointOrbit_Response& from) {
    IUAS_PointOrbit_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IUAS_PointOrbit_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.IUAS_PointOrbit_Response";
  }
  protected:
  explicit IUAS_PointOrbit_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.IUAS_PointOrbit_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class IUAS_PointHover_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.IUAS_PointHover_Request) */ {
 public:
  inline IUAS_PointHover_Request() : IUAS_PointHover_Request(nullptr) {}
  ~IUAS_PointHover_Request() override;
  explicit PROTOBUF_CONSTEXPR IUAS_PointHover_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IUAS_PointHover_Request(const IUAS_PointHover_Request& from);
  IUAS_PointHover_Request(IUAS_PointHover_Request&& from) noexcept
    : IUAS_PointHover_Request() {
    *this = ::std::move(from);
  }

  inline IUAS_PointHover_Request& operator=(const IUAS_PointHover_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline IUAS_PointHover_Request& operator=(IUAS_PointHover_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IUAS_PointHover_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const IUAS_PointHover_Request* internal_default_instance() {
    return reinterpret_cast<const IUAS_PointHover_Request*>(
               &_IUAS_PointHover_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(IUAS_PointHover_Request& a, IUAS_PointHover_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(IUAS_PointHover_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IUAS_PointHover_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IUAS_PointHover_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IUAS_PointHover_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IUAS_PointHover_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IUAS_PointHover_Request& from) {
    IUAS_PointHover_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IUAS_PointHover_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.IUAS_PointHover_Request";
  }
  protected:
  explicit IUAS_PointHover_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
  };
  // .muas.Position pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::muas::Position& pos() const;
  PROTOBUF_NODISCARD ::muas::Position* release_pos();
  ::muas::Position* mutable_pos();
  void set_allocated_pos(::muas::Position* pos);
  private:
  const ::muas::Position& _internal_pos() const;
  ::muas::Position* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::muas::Position* pos);
  ::muas::Position* unsafe_arena_release_pos();

  // @@protoc_insertion_point(class_scope:muas.IUAS_PointHover_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::Position* pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class IUAS_PointHover_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.IUAS_PointHover_Response) */ {
 public:
  inline IUAS_PointHover_Response() : IUAS_PointHover_Response(nullptr) {}
  ~IUAS_PointHover_Response() override;
  explicit PROTOBUF_CONSTEXPR IUAS_PointHover_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IUAS_PointHover_Response(const IUAS_PointHover_Response& from);
  IUAS_PointHover_Response(IUAS_PointHover_Response&& from) noexcept
    : IUAS_PointHover_Response() {
    *this = ::std::move(from);
  }

  inline IUAS_PointHover_Response& operator=(const IUAS_PointHover_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline IUAS_PointHover_Response& operator=(IUAS_PointHover_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IUAS_PointHover_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const IUAS_PointHover_Response* internal_default_instance() {
    return reinterpret_cast<const IUAS_PointHover_Response*>(
               &_IUAS_PointHover_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(IUAS_PointHover_Response& a, IUAS_PointHover_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(IUAS_PointHover_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IUAS_PointHover_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IUAS_PointHover_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IUAS_PointHover_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IUAS_PointHover_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IUAS_PointHover_Response& from) {
    IUAS_PointHover_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IUAS_PointHover_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.IUAS_PointHover_Response";
  }
  protected:
  explicit IUAS_PointHover_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.IUAS_PointHover_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_GetMissionInfo_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.Mission_GetMissionInfo_Request) */ {
 public:
  inline Mission_GetMissionInfo_Request() : Mission_GetMissionInfo_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Mission_GetMissionInfo_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_GetMissionInfo_Request(const Mission_GetMissionInfo_Request& from);
  Mission_GetMissionInfo_Request(Mission_GetMissionInfo_Request&& from) noexcept
    : Mission_GetMissionInfo_Request() {
    *this = ::std::move(from);
  }

  inline Mission_GetMissionInfo_Request& operator=(const Mission_GetMissionInfo_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_GetMissionInfo_Request& operator=(Mission_GetMissionInfo_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_GetMissionInfo_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_GetMissionInfo_Request* internal_default_instance() {
    return reinterpret_cast<const Mission_GetMissionInfo_Request*>(
               &_Mission_GetMissionInfo_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Mission_GetMissionInfo_Request& a, Mission_GetMissionInfo_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_GetMissionInfo_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_GetMissionInfo_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_GetMissionInfo_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_GetMissionInfo_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Mission_GetMissionInfo_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Mission_GetMissionInfo_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_GetMissionInfo_Request";
  }
  protected:
  explicit Mission_GetMissionInfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.Mission_GetMissionInfo_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_GetMissionInfo_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Mission_GetMissionInfo_Response) */ {
 public:
  inline Mission_GetMissionInfo_Response() : Mission_GetMissionInfo_Response(nullptr) {}
  ~Mission_GetMissionInfo_Response() override;
  explicit PROTOBUF_CONSTEXPR Mission_GetMissionInfo_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_GetMissionInfo_Response(const Mission_GetMissionInfo_Response& from);
  Mission_GetMissionInfo_Response(Mission_GetMissionInfo_Response&& from) noexcept
    : Mission_GetMissionInfo_Response() {
    *this = ::std::move(from);
  }

  inline Mission_GetMissionInfo_Response& operator=(const Mission_GetMissionInfo_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_GetMissionInfo_Response& operator=(Mission_GetMissionInfo_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_GetMissionInfo_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_GetMissionInfo_Response* internal_default_instance() {
    return reinterpret_cast<const Mission_GetMissionInfo_Response*>(
               &_Mission_GetMissionInfo_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Mission_GetMissionInfo_Response& a, Mission_GetMissionInfo_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_GetMissionInfo_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_GetMissionInfo_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_GetMissionInfo_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_GetMissionInfo_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mission_GetMissionInfo_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mission_GetMissionInfo_Response& from) {
    Mission_GetMissionInfo_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mission_GetMissionInfo_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_GetMissionInfo_Response";
  }
  protected:
  explicit Mission_GetMissionInfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // .muas.MissionInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::muas::MissionInfo& info() const;
  PROTOBUF_NODISCARD ::muas::MissionInfo* release_info();
  ::muas::MissionInfo* mutable_info();
  void set_allocated_info(::muas::MissionInfo* info);
  private:
  const ::muas::MissionInfo& _internal_info() const;
  ::muas::MissionInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::muas::MissionInfo* info);
  ::muas::MissionInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:muas.Mission_GetMissionInfo_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    ::muas::MissionInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_GetItem_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Mission_GetItem_Request) */ {
 public:
  inline Mission_GetItem_Request() : Mission_GetItem_Request(nullptr) {}
  ~Mission_GetItem_Request() override;
  explicit PROTOBUF_CONSTEXPR Mission_GetItem_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_GetItem_Request(const Mission_GetItem_Request& from);
  Mission_GetItem_Request(Mission_GetItem_Request&& from) noexcept
    : Mission_GetItem_Request() {
    *this = ::std::move(from);
  }

  inline Mission_GetItem_Request& operator=(const Mission_GetItem_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_GetItem_Request& operator=(Mission_GetItem_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_GetItem_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_GetItem_Request* internal_default_instance() {
    return reinterpret_cast<const Mission_GetItem_Request*>(
               &_Mission_GetItem_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Mission_GetItem_Request& a, Mission_GetItem_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_GetItem_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_GetItem_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_GetItem_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_GetItem_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mission_GetItem_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mission_GetItem_Request& from) {
    Mission_GetItem_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mission_GetItem_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_GetItem_Request";
  }
  protected:
  explicit Mission_GetItem_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdxFieldNumber = 1,
  };
  // int32 idx = 1;
  void clear_idx();
  int32_t idx() const;
  void set_idx(int32_t value);
  private:
  int32_t _internal_idx() const;
  void _internal_set_idx(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:muas.Mission_GetItem_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_GetItem_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Mission_GetItem_Response) */ {
 public:
  inline Mission_GetItem_Response() : Mission_GetItem_Response(nullptr) {}
  ~Mission_GetItem_Response() override;
  explicit PROTOBUF_CONSTEXPR Mission_GetItem_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_GetItem_Response(const Mission_GetItem_Response& from);
  Mission_GetItem_Response(Mission_GetItem_Response&& from) noexcept
    : Mission_GetItem_Response() {
    *this = ::std::move(from);
  }

  inline Mission_GetItem_Response& operator=(const Mission_GetItem_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_GetItem_Response& operator=(Mission_GetItem_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_GetItem_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_GetItem_Response* internal_default_instance() {
    return reinterpret_cast<const Mission_GetItem_Response*>(
               &_Mission_GetItem_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Mission_GetItem_Response& a, Mission_GetItem_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_GetItem_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_GetItem_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_GetItem_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_GetItem_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mission_GetItem_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mission_GetItem_Response& from) {
    Mission_GetItem_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mission_GetItem_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_GetItem_Response";
  }
  protected:
  explicit Mission_GetItem_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kItemFieldNumber = 2,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // .muas.MissionItem item = 2;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::muas::MissionItem& item() const;
  PROTOBUF_NODISCARD ::muas::MissionItem* release_item();
  ::muas::MissionItem* mutable_item();
  void set_allocated_item(::muas::MissionItem* item);
  private:
  const ::muas::MissionItem& _internal_item() const;
  ::muas::MissionItem* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::muas::MissionItem* item);
  ::muas::MissionItem* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:muas.Mission_GetItem_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    ::muas::MissionItem* item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_SetItem_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Mission_SetItem_Request) */ {
 public:
  inline Mission_SetItem_Request() : Mission_SetItem_Request(nullptr) {}
  ~Mission_SetItem_Request() override;
  explicit PROTOBUF_CONSTEXPR Mission_SetItem_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_SetItem_Request(const Mission_SetItem_Request& from);
  Mission_SetItem_Request(Mission_SetItem_Request&& from) noexcept
    : Mission_SetItem_Request() {
    *this = ::std::move(from);
  }

  inline Mission_SetItem_Request& operator=(const Mission_SetItem_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_SetItem_Request& operator=(Mission_SetItem_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_SetItem_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_SetItem_Request* internal_default_instance() {
    return reinterpret_cast<const Mission_SetItem_Request*>(
               &_Mission_SetItem_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Mission_SetItem_Request& a, Mission_SetItem_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_SetItem_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_SetItem_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_SetItem_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_SetItem_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mission_SetItem_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mission_SetItem_Request& from) {
    Mission_SetItem_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mission_SetItem_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_SetItem_Request";
  }
  protected:
  explicit Mission_SetItem_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 2,
    kIdxFieldNumber = 1,
  };
  // .muas.MissionItem item = 2;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::muas::MissionItem& item() const;
  PROTOBUF_NODISCARD ::muas::MissionItem* release_item();
  ::muas::MissionItem* mutable_item();
  void set_allocated_item(::muas::MissionItem* item);
  private:
  const ::muas::MissionItem& _internal_item() const;
  ::muas::MissionItem* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::muas::MissionItem* item);
  ::muas::MissionItem* unsafe_arena_release_item();

  // int32 idx = 1;
  void clear_idx();
  int32_t idx() const;
  void set_idx(int32_t value);
  private:
  int32_t _internal_idx() const;
  void _internal_set_idx(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:muas.Mission_SetItem_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::MissionItem* item_;
    int32_t idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_SetItem_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Mission_SetItem_Response) */ {
 public:
  inline Mission_SetItem_Response() : Mission_SetItem_Response(nullptr) {}
  ~Mission_SetItem_Response() override;
  explicit PROTOBUF_CONSTEXPR Mission_SetItem_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_SetItem_Response(const Mission_SetItem_Response& from);
  Mission_SetItem_Response(Mission_SetItem_Response&& from) noexcept
    : Mission_SetItem_Response() {
    *this = ::std::move(from);
  }

  inline Mission_SetItem_Response& operator=(const Mission_SetItem_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_SetItem_Response& operator=(Mission_SetItem_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_SetItem_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_SetItem_Response* internal_default_instance() {
    return reinterpret_cast<const Mission_SetItem_Response*>(
               &_Mission_SetItem_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Mission_SetItem_Response& a, Mission_SetItem_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_SetItem_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_SetItem_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_SetItem_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_SetItem_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mission_SetItem_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mission_SetItem_Response& from) {
    Mission_SetItem_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mission_SetItem_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_SetItem_Response";
  }
  protected:
  explicit Mission_SetItem_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.Mission_SetItem_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_Clear_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.Mission_Clear_Request) */ {
 public:
  inline Mission_Clear_Request() : Mission_Clear_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Mission_Clear_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_Clear_Request(const Mission_Clear_Request& from);
  Mission_Clear_Request(Mission_Clear_Request&& from) noexcept
    : Mission_Clear_Request() {
    *this = ::std::move(from);
  }

  inline Mission_Clear_Request& operator=(const Mission_Clear_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_Clear_Request& operator=(Mission_Clear_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_Clear_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_Clear_Request* internal_default_instance() {
    return reinterpret_cast<const Mission_Clear_Request*>(
               &_Mission_Clear_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Mission_Clear_Request& a, Mission_Clear_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_Clear_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_Clear_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_Clear_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_Clear_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Mission_Clear_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Mission_Clear_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_Clear_Request";
  }
  protected:
  explicit Mission_Clear_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.Mission_Clear_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_Clear_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Mission_Clear_Response) */ {
 public:
  inline Mission_Clear_Response() : Mission_Clear_Response(nullptr) {}
  ~Mission_Clear_Response() override;
  explicit PROTOBUF_CONSTEXPR Mission_Clear_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_Clear_Response(const Mission_Clear_Response& from);
  Mission_Clear_Response(Mission_Clear_Response&& from) noexcept
    : Mission_Clear_Response() {
    *this = ::std::move(from);
  }

  inline Mission_Clear_Response& operator=(const Mission_Clear_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_Clear_Response& operator=(Mission_Clear_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_Clear_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_Clear_Response* internal_default_instance() {
    return reinterpret_cast<const Mission_Clear_Response*>(
               &_Mission_Clear_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Mission_Clear_Response& a, Mission_Clear_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_Clear_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_Clear_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_Clear_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_Clear_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mission_Clear_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mission_Clear_Response& from) {
    Mission_Clear_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mission_Clear_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_Clear_Response";
  }
  protected:
  explicit Mission_Clear_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.Mission_Clear_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_Start_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.Mission_Start_Request) */ {
 public:
  inline Mission_Start_Request() : Mission_Start_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Mission_Start_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_Start_Request(const Mission_Start_Request& from);
  Mission_Start_Request(Mission_Start_Request&& from) noexcept
    : Mission_Start_Request() {
    *this = ::std::move(from);
  }

  inline Mission_Start_Request& operator=(const Mission_Start_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_Start_Request& operator=(Mission_Start_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_Start_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_Start_Request* internal_default_instance() {
    return reinterpret_cast<const Mission_Start_Request*>(
               &_Mission_Start_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Mission_Start_Request& a, Mission_Start_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_Start_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_Start_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_Start_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_Start_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Mission_Start_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Mission_Start_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_Start_Request";
  }
  protected:
  explicit Mission_Start_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.Mission_Start_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_Start_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Mission_Start_Response) */ {
 public:
  inline Mission_Start_Response() : Mission_Start_Response(nullptr) {}
  ~Mission_Start_Response() override;
  explicit PROTOBUF_CONSTEXPR Mission_Start_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_Start_Response(const Mission_Start_Response& from);
  Mission_Start_Response(Mission_Start_Response&& from) noexcept
    : Mission_Start_Response() {
    *this = ::std::move(from);
  }

  inline Mission_Start_Response& operator=(const Mission_Start_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_Start_Response& operator=(Mission_Start_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_Start_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_Start_Response* internal_default_instance() {
    return reinterpret_cast<const Mission_Start_Response*>(
               &_Mission_Start_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Mission_Start_Response& a, Mission_Start_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_Start_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_Start_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_Start_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_Start_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mission_Start_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mission_Start_Response& from) {
    Mission_Start_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mission_Start_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_Start_Response";
  }
  protected:
  explicit Mission_Start_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.Mission_Start_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_Pause_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.Mission_Pause_Request) */ {
 public:
  inline Mission_Pause_Request() : Mission_Pause_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Mission_Pause_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_Pause_Request(const Mission_Pause_Request& from);
  Mission_Pause_Request(Mission_Pause_Request&& from) noexcept
    : Mission_Pause_Request() {
    *this = ::std::move(from);
  }

  inline Mission_Pause_Request& operator=(const Mission_Pause_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_Pause_Request& operator=(Mission_Pause_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_Pause_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_Pause_Request* internal_default_instance() {
    return reinterpret_cast<const Mission_Pause_Request*>(
               &_Mission_Pause_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Mission_Pause_Request& a, Mission_Pause_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_Pause_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_Pause_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_Pause_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_Pause_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Mission_Pause_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Mission_Pause_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_Pause_Request";
  }
  protected:
  explicit Mission_Pause_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.Mission_Pause_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_Pause_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Mission_Pause_Response) */ {
 public:
  inline Mission_Pause_Response() : Mission_Pause_Response(nullptr) {}
  ~Mission_Pause_Response() override;
  explicit PROTOBUF_CONSTEXPR Mission_Pause_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_Pause_Response(const Mission_Pause_Response& from);
  Mission_Pause_Response(Mission_Pause_Response&& from) noexcept
    : Mission_Pause_Response() {
    *this = ::std::move(from);
  }

  inline Mission_Pause_Response& operator=(const Mission_Pause_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_Pause_Response& operator=(Mission_Pause_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_Pause_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_Pause_Response* internal_default_instance() {
    return reinterpret_cast<const Mission_Pause_Response*>(
               &_Mission_Pause_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Mission_Pause_Response& a, Mission_Pause_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_Pause_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_Pause_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_Pause_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_Pause_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mission_Pause_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mission_Pause_Response& from) {
    Mission_Pause_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mission_Pause_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_Pause_Response";
  }
  protected:
  explicit Mission_Pause_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.Mission_Pause_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_Continue_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.Mission_Continue_Request) */ {
 public:
  inline Mission_Continue_Request() : Mission_Continue_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Mission_Continue_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_Continue_Request(const Mission_Continue_Request& from);
  Mission_Continue_Request(Mission_Continue_Request&& from) noexcept
    : Mission_Continue_Request() {
    *this = ::std::move(from);
  }

  inline Mission_Continue_Request& operator=(const Mission_Continue_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_Continue_Request& operator=(Mission_Continue_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_Continue_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_Continue_Request* internal_default_instance() {
    return reinterpret_cast<const Mission_Continue_Request*>(
               &_Mission_Continue_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Mission_Continue_Request& a, Mission_Continue_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_Continue_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_Continue_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_Continue_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_Continue_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Mission_Continue_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Mission_Continue_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_Continue_Request";
  }
  protected:
  explicit Mission_Continue_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.Mission_Continue_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_Continue_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Mission_Continue_Response) */ {
 public:
  inline Mission_Continue_Response() : Mission_Continue_Response(nullptr) {}
  ~Mission_Continue_Response() override;
  explicit PROTOBUF_CONSTEXPR Mission_Continue_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_Continue_Response(const Mission_Continue_Response& from);
  Mission_Continue_Response(Mission_Continue_Response&& from) noexcept
    : Mission_Continue_Response() {
    *this = ::std::move(from);
  }

  inline Mission_Continue_Response& operator=(const Mission_Continue_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_Continue_Response& operator=(Mission_Continue_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_Continue_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_Continue_Response* internal_default_instance() {
    return reinterpret_cast<const Mission_Continue_Response*>(
               &_Mission_Continue_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Mission_Continue_Response& a, Mission_Continue_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_Continue_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_Continue_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_Continue_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_Continue_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mission_Continue_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mission_Continue_Response& from) {
    Mission_Continue_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mission_Continue_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_Continue_Response";
  }
  protected:
  explicit Mission_Continue_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.Mission_Continue_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_Terminate_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.Mission_Terminate_Request) */ {
 public:
  inline Mission_Terminate_Request() : Mission_Terminate_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Mission_Terminate_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_Terminate_Request(const Mission_Terminate_Request& from);
  Mission_Terminate_Request(Mission_Terminate_Request&& from) noexcept
    : Mission_Terminate_Request() {
    *this = ::std::move(from);
  }

  inline Mission_Terminate_Request& operator=(const Mission_Terminate_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_Terminate_Request& operator=(Mission_Terminate_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_Terminate_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_Terminate_Request* internal_default_instance() {
    return reinterpret_cast<const Mission_Terminate_Request*>(
               &_Mission_Terminate_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Mission_Terminate_Request& a, Mission_Terminate_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_Terminate_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_Terminate_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_Terminate_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_Terminate_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Mission_Terminate_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Mission_Terminate_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_Terminate_Request";
  }
  protected:
  explicit Mission_Terminate_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.Mission_Terminate_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Mission_Terminate_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.Mission_Terminate_Response) */ {
 public:
  inline Mission_Terminate_Response() : Mission_Terminate_Response(nullptr) {}
  ~Mission_Terminate_Response() override;
  explicit PROTOBUF_CONSTEXPR Mission_Terminate_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mission_Terminate_Response(const Mission_Terminate_Response& from);
  Mission_Terminate_Response(Mission_Terminate_Response&& from) noexcept
    : Mission_Terminate_Response() {
    *this = ::std::move(from);
  }

  inline Mission_Terminate_Response& operator=(const Mission_Terminate_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mission_Terminate_Response& operator=(Mission_Terminate_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mission_Terminate_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mission_Terminate_Response* internal_default_instance() {
    return reinterpret_cast<const Mission_Terminate_Response*>(
               &_Mission_Terminate_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Mission_Terminate_Response& a, Mission_Terminate_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Mission_Terminate_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mission_Terminate_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mission_Terminate_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mission_Terminate_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mission_Terminate_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mission_Terminate_Response& from) {
    Mission_Terminate_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mission_Terminate_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.Mission_Terminate_Response";
  }
  protected:
  explicit Mission_Terminate_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.Mission_Terminate_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlightCtrl_SwitchMode_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.FlightCtrl_SwitchMode_Request) */ {
 public:
  inline FlightCtrl_SwitchMode_Request() : FlightCtrl_SwitchMode_Request(nullptr) {}
  ~FlightCtrl_SwitchMode_Request() override;
  explicit PROTOBUF_CONSTEXPR FlightCtrl_SwitchMode_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightCtrl_SwitchMode_Request(const FlightCtrl_SwitchMode_Request& from);
  FlightCtrl_SwitchMode_Request(FlightCtrl_SwitchMode_Request&& from) noexcept
    : FlightCtrl_SwitchMode_Request() {
    *this = ::std::move(from);
  }

  inline FlightCtrl_SwitchMode_Request& operator=(const FlightCtrl_SwitchMode_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightCtrl_SwitchMode_Request& operator=(FlightCtrl_SwitchMode_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightCtrl_SwitchMode_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightCtrl_SwitchMode_Request* internal_default_instance() {
    return reinterpret_cast<const FlightCtrl_SwitchMode_Request*>(
               &_FlightCtrl_SwitchMode_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(FlightCtrl_SwitchMode_Request& a, FlightCtrl_SwitchMode_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightCtrl_SwitchMode_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightCtrl_SwitchMode_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightCtrl_SwitchMode_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightCtrl_SwitchMode_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightCtrl_SwitchMode_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightCtrl_SwitchMode_Request& from) {
    FlightCtrl_SwitchMode_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightCtrl_SwitchMode_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.FlightCtrl_SwitchMode_Request";
  }
  protected:
  explicit FlightCtrl_SwitchMode_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FlightCtrl_SwitchMode_Request_FlightMode FlightMode;
  static constexpr FlightMode UNKNOWN =
    FlightCtrl_SwitchMode_Request_FlightMode_UNKNOWN;
  static constexpr FlightMode STABILIZE =
    FlightCtrl_SwitchMode_Request_FlightMode_STABILIZE;
  static constexpr FlightMode ALT_HOLD =
    FlightCtrl_SwitchMode_Request_FlightMode_ALT_HOLD;
  static constexpr FlightMode LOITER =
    FlightCtrl_SwitchMode_Request_FlightMode_LOITER;
  static constexpr FlightMode GUIDED =
    FlightCtrl_SwitchMode_Request_FlightMode_GUIDED;
  static inline bool FlightMode_IsValid(int value) {
    return FlightCtrl_SwitchMode_Request_FlightMode_IsValid(value);
  }
  static constexpr FlightMode FlightMode_MIN =
    FlightCtrl_SwitchMode_Request_FlightMode_FlightMode_MIN;
  static constexpr FlightMode FlightMode_MAX =
    FlightCtrl_SwitchMode_Request_FlightMode_FlightMode_MAX;
  static constexpr int FlightMode_ARRAYSIZE =
    FlightCtrl_SwitchMode_Request_FlightMode_FlightMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FlightMode_descriptor() {
    return FlightCtrl_SwitchMode_Request_FlightMode_descriptor();
  }
  template<typename T>
  static inline const std::string& FlightMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FlightMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FlightMode_Name.");
    return FlightCtrl_SwitchMode_Request_FlightMode_Name(enum_t_value);
  }
  static inline bool FlightMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FlightMode* value) {
    return FlightCtrl_SwitchMode_Request_FlightMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // .muas.FlightCtrl_SwitchMode_Request.FlightMode mode = 1;
  void clear_mode();
  ::muas::FlightCtrl_SwitchMode_Request_FlightMode mode() const;
  void set_mode(::muas::FlightCtrl_SwitchMode_Request_FlightMode value);
  private:
  ::muas::FlightCtrl_SwitchMode_Request_FlightMode _internal_mode() const;
  void _internal_set_mode(::muas::FlightCtrl_SwitchMode_Request_FlightMode value);
  public:

  // @@protoc_insertion_point(class_scope:muas.FlightCtrl_SwitchMode_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlightCtrl_SwitchMode_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.FlightCtrl_SwitchMode_Response) */ {
 public:
  inline FlightCtrl_SwitchMode_Response() : FlightCtrl_SwitchMode_Response(nullptr) {}
  ~FlightCtrl_SwitchMode_Response() override;
  explicit PROTOBUF_CONSTEXPR FlightCtrl_SwitchMode_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightCtrl_SwitchMode_Response(const FlightCtrl_SwitchMode_Response& from);
  FlightCtrl_SwitchMode_Response(FlightCtrl_SwitchMode_Response&& from) noexcept
    : FlightCtrl_SwitchMode_Response() {
    *this = ::std::move(from);
  }

  inline FlightCtrl_SwitchMode_Response& operator=(const FlightCtrl_SwitchMode_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightCtrl_SwitchMode_Response& operator=(FlightCtrl_SwitchMode_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightCtrl_SwitchMode_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightCtrl_SwitchMode_Response* internal_default_instance() {
    return reinterpret_cast<const FlightCtrl_SwitchMode_Response*>(
               &_FlightCtrl_SwitchMode_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(FlightCtrl_SwitchMode_Response& a, FlightCtrl_SwitchMode_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightCtrl_SwitchMode_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightCtrl_SwitchMode_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightCtrl_SwitchMode_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightCtrl_SwitchMode_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightCtrl_SwitchMode_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightCtrl_SwitchMode_Response& from) {
    FlightCtrl_SwitchMode_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightCtrl_SwitchMode_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.FlightCtrl_SwitchMode_Response";
  }
  protected:
  explicit FlightCtrl_SwitchMode_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.FlightCtrl_SwitchMode_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlightCtrl_Takeoff_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.FlightCtrl_Takeoff_Request) */ {
 public:
  inline FlightCtrl_Takeoff_Request() : FlightCtrl_Takeoff_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FlightCtrl_Takeoff_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightCtrl_Takeoff_Request(const FlightCtrl_Takeoff_Request& from);
  FlightCtrl_Takeoff_Request(FlightCtrl_Takeoff_Request&& from) noexcept
    : FlightCtrl_Takeoff_Request() {
    *this = ::std::move(from);
  }

  inline FlightCtrl_Takeoff_Request& operator=(const FlightCtrl_Takeoff_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightCtrl_Takeoff_Request& operator=(FlightCtrl_Takeoff_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightCtrl_Takeoff_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightCtrl_Takeoff_Request* internal_default_instance() {
    return reinterpret_cast<const FlightCtrl_Takeoff_Request*>(
               &_FlightCtrl_Takeoff_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(FlightCtrl_Takeoff_Request& a, FlightCtrl_Takeoff_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightCtrl_Takeoff_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightCtrl_Takeoff_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightCtrl_Takeoff_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightCtrl_Takeoff_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FlightCtrl_Takeoff_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FlightCtrl_Takeoff_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.FlightCtrl_Takeoff_Request";
  }
  protected:
  explicit FlightCtrl_Takeoff_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.FlightCtrl_Takeoff_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlightCtrl_Takeoff_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.FlightCtrl_Takeoff_Response) */ {
 public:
  inline FlightCtrl_Takeoff_Response() : FlightCtrl_Takeoff_Response(nullptr) {}
  ~FlightCtrl_Takeoff_Response() override;
  explicit PROTOBUF_CONSTEXPR FlightCtrl_Takeoff_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightCtrl_Takeoff_Response(const FlightCtrl_Takeoff_Response& from);
  FlightCtrl_Takeoff_Response(FlightCtrl_Takeoff_Response&& from) noexcept
    : FlightCtrl_Takeoff_Response() {
    *this = ::std::move(from);
  }

  inline FlightCtrl_Takeoff_Response& operator=(const FlightCtrl_Takeoff_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightCtrl_Takeoff_Response& operator=(FlightCtrl_Takeoff_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightCtrl_Takeoff_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightCtrl_Takeoff_Response* internal_default_instance() {
    return reinterpret_cast<const FlightCtrl_Takeoff_Response*>(
               &_FlightCtrl_Takeoff_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(FlightCtrl_Takeoff_Response& a, FlightCtrl_Takeoff_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightCtrl_Takeoff_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightCtrl_Takeoff_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightCtrl_Takeoff_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightCtrl_Takeoff_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightCtrl_Takeoff_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightCtrl_Takeoff_Response& from) {
    FlightCtrl_Takeoff_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightCtrl_Takeoff_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.FlightCtrl_Takeoff_Response";
  }
  protected:
  explicit FlightCtrl_Takeoff_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.FlightCtrl_Takeoff_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlightCtrl_Land_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.FlightCtrl_Land_Request) */ {
 public:
  inline FlightCtrl_Land_Request() : FlightCtrl_Land_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FlightCtrl_Land_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightCtrl_Land_Request(const FlightCtrl_Land_Request& from);
  FlightCtrl_Land_Request(FlightCtrl_Land_Request&& from) noexcept
    : FlightCtrl_Land_Request() {
    *this = ::std::move(from);
  }

  inline FlightCtrl_Land_Request& operator=(const FlightCtrl_Land_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightCtrl_Land_Request& operator=(FlightCtrl_Land_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightCtrl_Land_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightCtrl_Land_Request* internal_default_instance() {
    return reinterpret_cast<const FlightCtrl_Land_Request*>(
               &_FlightCtrl_Land_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(FlightCtrl_Land_Request& a, FlightCtrl_Land_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightCtrl_Land_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightCtrl_Land_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightCtrl_Land_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightCtrl_Land_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FlightCtrl_Land_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FlightCtrl_Land_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.FlightCtrl_Land_Request";
  }
  protected:
  explicit FlightCtrl_Land_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.FlightCtrl_Land_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlightCtrl_Land_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.FlightCtrl_Land_Response) */ {
 public:
  inline FlightCtrl_Land_Response() : FlightCtrl_Land_Response(nullptr) {}
  ~FlightCtrl_Land_Response() override;
  explicit PROTOBUF_CONSTEXPR FlightCtrl_Land_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightCtrl_Land_Response(const FlightCtrl_Land_Response& from);
  FlightCtrl_Land_Response(FlightCtrl_Land_Response&& from) noexcept
    : FlightCtrl_Land_Response() {
    *this = ::std::move(from);
  }

  inline FlightCtrl_Land_Response& operator=(const FlightCtrl_Land_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightCtrl_Land_Response& operator=(FlightCtrl_Land_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightCtrl_Land_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightCtrl_Land_Response* internal_default_instance() {
    return reinterpret_cast<const FlightCtrl_Land_Response*>(
               &_FlightCtrl_Land_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(FlightCtrl_Land_Response& a, FlightCtrl_Land_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightCtrl_Land_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightCtrl_Land_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightCtrl_Land_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightCtrl_Land_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightCtrl_Land_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightCtrl_Land_Response& from) {
    FlightCtrl_Land_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightCtrl_Land_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.FlightCtrl_Land_Response";
  }
  protected:
  explicit FlightCtrl_Land_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.FlightCtrl_Land_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlightCtrl_RTL_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.FlightCtrl_RTL_Request) */ {
 public:
  inline FlightCtrl_RTL_Request() : FlightCtrl_RTL_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FlightCtrl_RTL_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightCtrl_RTL_Request(const FlightCtrl_RTL_Request& from);
  FlightCtrl_RTL_Request(FlightCtrl_RTL_Request&& from) noexcept
    : FlightCtrl_RTL_Request() {
    *this = ::std::move(from);
  }

  inline FlightCtrl_RTL_Request& operator=(const FlightCtrl_RTL_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightCtrl_RTL_Request& operator=(FlightCtrl_RTL_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightCtrl_RTL_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightCtrl_RTL_Request* internal_default_instance() {
    return reinterpret_cast<const FlightCtrl_RTL_Request*>(
               &_FlightCtrl_RTL_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(FlightCtrl_RTL_Request& a, FlightCtrl_RTL_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightCtrl_RTL_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightCtrl_RTL_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightCtrl_RTL_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightCtrl_RTL_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FlightCtrl_RTL_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FlightCtrl_RTL_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.FlightCtrl_RTL_Request";
  }
  protected:
  explicit FlightCtrl_RTL_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.FlightCtrl_RTL_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlightCtrl_RTL_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.FlightCtrl_RTL_Response) */ {
 public:
  inline FlightCtrl_RTL_Response() : FlightCtrl_RTL_Response(nullptr) {}
  ~FlightCtrl_RTL_Response() override;
  explicit PROTOBUF_CONSTEXPR FlightCtrl_RTL_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightCtrl_RTL_Response(const FlightCtrl_RTL_Response& from);
  FlightCtrl_RTL_Response(FlightCtrl_RTL_Response&& from) noexcept
    : FlightCtrl_RTL_Response() {
    *this = ::std::move(from);
  }

  inline FlightCtrl_RTL_Response& operator=(const FlightCtrl_RTL_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightCtrl_RTL_Response& operator=(FlightCtrl_RTL_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightCtrl_RTL_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightCtrl_RTL_Response* internal_default_instance() {
    return reinterpret_cast<const FlightCtrl_RTL_Response*>(
               &_FlightCtrl_RTL_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(FlightCtrl_RTL_Response& a, FlightCtrl_RTL_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightCtrl_RTL_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightCtrl_RTL_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightCtrl_RTL_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightCtrl_RTL_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightCtrl_RTL_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightCtrl_RTL_Response& from) {
    FlightCtrl_RTL_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightCtrl_RTL_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.FlightCtrl_RTL_Response";
  }
  protected:
  explicit FlightCtrl_RTL_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.FlightCtrl_RTL_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlightCtrl_Kill_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.FlightCtrl_Kill_Request) */ {
 public:
  inline FlightCtrl_Kill_Request() : FlightCtrl_Kill_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FlightCtrl_Kill_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightCtrl_Kill_Request(const FlightCtrl_Kill_Request& from);
  FlightCtrl_Kill_Request(FlightCtrl_Kill_Request&& from) noexcept
    : FlightCtrl_Kill_Request() {
    *this = ::std::move(from);
  }

  inline FlightCtrl_Kill_Request& operator=(const FlightCtrl_Kill_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightCtrl_Kill_Request& operator=(FlightCtrl_Kill_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightCtrl_Kill_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightCtrl_Kill_Request* internal_default_instance() {
    return reinterpret_cast<const FlightCtrl_Kill_Request*>(
               &_FlightCtrl_Kill_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(FlightCtrl_Kill_Request& a, FlightCtrl_Kill_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightCtrl_Kill_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightCtrl_Kill_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightCtrl_Kill_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightCtrl_Kill_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FlightCtrl_Kill_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FlightCtrl_Kill_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.FlightCtrl_Kill_Request";
  }
  protected:
  explicit FlightCtrl_Kill_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.FlightCtrl_Kill_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlightCtrl_Kill_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.FlightCtrl_Kill_Response) */ {
 public:
  inline FlightCtrl_Kill_Response() : FlightCtrl_Kill_Response(nullptr) {}
  ~FlightCtrl_Kill_Response() override;
  explicit PROTOBUF_CONSTEXPR FlightCtrl_Kill_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightCtrl_Kill_Response(const FlightCtrl_Kill_Response& from);
  FlightCtrl_Kill_Response(FlightCtrl_Kill_Response&& from) noexcept
    : FlightCtrl_Kill_Response() {
    *this = ::std::move(from);
  }

  inline FlightCtrl_Kill_Response& operator=(const FlightCtrl_Kill_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightCtrl_Kill_Response& operator=(FlightCtrl_Kill_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightCtrl_Kill_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightCtrl_Kill_Response* internal_default_instance() {
    return reinterpret_cast<const FlightCtrl_Kill_Response*>(
               &_FlightCtrl_Kill_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(FlightCtrl_Kill_Response& a, FlightCtrl_Kill_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightCtrl_Kill_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightCtrl_Kill_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightCtrl_Kill_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightCtrl_Kill_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightCtrl_Kill_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightCtrl_Kill_Response& from) {
    FlightCtrl_Kill_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightCtrl_Kill_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.FlightCtrl_Kill_Response";
  }
  protected:
  explicit FlightCtrl_Kill_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.FlightCtrl_Kill_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlightCtrl_SetSpeed_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.FlightCtrl_SetSpeed_Request) */ {
 public:
  inline FlightCtrl_SetSpeed_Request() : FlightCtrl_SetSpeed_Request(nullptr) {}
  ~FlightCtrl_SetSpeed_Request() override;
  explicit PROTOBUF_CONSTEXPR FlightCtrl_SetSpeed_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightCtrl_SetSpeed_Request(const FlightCtrl_SetSpeed_Request& from);
  FlightCtrl_SetSpeed_Request(FlightCtrl_SetSpeed_Request&& from) noexcept
    : FlightCtrl_SetSpeed_Request() {
    *this = ::std::move(from);
  }

  inline FlightCtrl_SetSpeed_Request& operator=(const FlightCtrl_SetSpeed_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightCtrl_SetSpeed_Request& operator=(FlightCtrl_SetSpeed_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightCtrl_SetSpeed_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightCtrl_SetSpeed_Request* internal_default_instance() {
    return reinterpret_cast<const FlightCtrl_SetSpeed_Request*>(
               &_FlightCtrl_SetSpeed_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(FlightCtrl_SetSpeed_Request& a, FlightCtrl_SetSpeed_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightCtrl_SetSpeed_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightCtrl_SetSpeed_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightCtrl_SetSpeed_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightCtrl_SetSpeed_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightCtrl_SetSpeed_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightCtrl_SetSpeed_Request& from) {
    FlightCtrl_SetSpeed_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightCtrl_SetSpeed_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.FlightCtrl_SetSpeed_Request";
  }
  protected:
  explicit FlightCtrl_SetSpeed_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedFieldNumber = 1,
  };
  // int32 speed = 1;
  void clear_speed();
  int32_t speed() const;
  void set_speed(int32_t value);
  private:
  int32_t _internal_speed() const;
  void _internal_set_speed(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:muas.FlightCtrl_SetSpeed_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t speed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlightCtrl_SetSpeed_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.FlightCtrl_SetSpeed_Response) */ {
 public:
  inline FlightCtrl_SetSpeed_Response() : FlightCtrl_SetSpeed_Response(nullptr) {}
  ~FlightCtrl_SetSpeed_Response() override;
  explicit PROTOBUF_CONSTEXPR FlightCtrl_SetSpeed_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightCtrl_SetSpeed_Response(const FlightCtrl_SetSpeed_Response& from);
  FlightCtrl_SetSpeed_Response(FlightCtrl_SetSpeed_Response&& from) noexcept
    : FlightCtrl_SetSpeed_Response() {
    *this = ::std::move(from);
  }

  inline FlightCtrl_SetSpeed_Response& operator=(const FlightCtrl_SetSpeed_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightCtrl_SetSpeed_Response& operator=(FlightCtrl_SetSpeed_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightCtrl_SetSpeed_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightCtrl_SetSpeed_Response* internal_default_instance() {
    return reinterpret_cast<const FlightCtrl_SetSpeed_Response*>(
               &_FlightCtrl_SetSpeed_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(FlightCtrl_SetSpeed_Response& a, FlightCtrl_SetSpeed_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightCtrl_SetSpeed_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightCtrl_SetSpeed_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightCtrl_SetSpeed_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightCtrl_SetSpeed_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightCtrl_SetSpeed_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightCtrl_SetSpeed_Response& from) {
    FlightCtrl_SetSpeed_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightCtrl_SetSpeed_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.FlightCtrl_SetSpeed_Response";
  }
  protected:
  explicit FlightCtrl_SetSpeed_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.FlightCtrl_SetSpeed_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlightCtrl_Reposition_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.FlightCtrl_Reposition_Request) */ {
 public:
  inline FlightCtrl_Reposition_Request() : FlightCtrl_Reposition_Request(nullptr) {}
  ~FlightCtrl_Reposition_Request() override;
  explicit PROTOBUF_CONSTEXPR FlightCtrl_Reposition_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightCtrl_Reposition_Request(const FlightCtrl_Reposition_Request& from);
  FlightCtrl_Reposition_Request(FlightCtrl_Reposition_Request&& from) noexcept
    : FlightCtrl_Reposition_Request() {
    *this = ::std::move(from);
  }

  inline FlightCtrl_Reposition_Request& operator=(const FlightCtrl_Reposition_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightCtrl_Reposition_Request& operator=(FlightCtrl_Reposition_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightCtrl_Reposition_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightCtrl_Reposition_Request* internal_default_instance() {
    return reinterpret_cast<const FlightCtrl_Reposition_Request*>(
               &_FlightCtrl_Reposition_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(FlightCtrl_Reposition_Request& a, FlightCtrl_Reposition_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightCtrl_Reposition_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightCtrl_Reposition_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightCtrl_Reposition_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightCtrl_Reposition_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightCtrl_Reposition_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightCtrl_Reposition_Request& from) {
    FlightCtrl_Reposition_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightCtrl_Reposition_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.FlightCtrl_Reposition_Request";
  }
  protected:
  explicit FlightCtrl_Reposition_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
  };
  // .muas.Position pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::muas::Position& pos() const;
  PROTOBUF_NODISCARD ::muas::Position* release_pos();
  ::muas::Position* mutable_pos();
  void set_allocated_pos(::muas::Position* pos);
  private:
  const ::muas::Position& _internal_pos() const;
  ::muas::Position* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::muas::Position* pos);
  ::muas::Position* unsafe_arena_release_pos();

  // @@protoc_insertion_point(class_scope:muas.FlightCtrl_Reposition_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::Position* pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlightCtrl_Reposition_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.FlightCtrl_Reposition_Response) */ {
 public:
  inline FlightCtrl_Reposition_Response() : FlightCtrl_Reposition_Response(nullptr) {}
  ~FlightCtrl_Reposition_Response() override;
  explicit PROTOBUF_CONSTEXPR FlightCtrl_Reposition_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightCtrl_Reposition_Response(const FlightCtrl_Reposition_Response& from);
  FlightCtrl_Reposition_Response(FlightCtrl_Reposition_Response&& from) noexcept
    : FlightCtrl_Reposition_Response() {
    *this = ::std::move(from);
  }

  inline FlightCtrl_Reposition_Response& operator=(const FlightCtrl_Reposition_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightCtrl_Reposition_Response& operator=(FlightCtrl_Reposition_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightCtrl_Reposition_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightCtrl_Reposition_Response* internal_default_instance() {
    return reinterpret_cast<const FlightCtrl_Reposition_Response*>(
               &_FlightCtrl_Reposition_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(FlightCtrl_Reposition_Response& a, FlightCtrl_Reposition_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightCtrl_Reposition_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightCtrl_Reposition_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightCtrl_Reposition_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightCtrl_Reposition_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightCtrl_Reposition_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightCtrl_Reposition_Response& from) {
    FlightCtrl_Reposition_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightCtrl_Reposition_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.FlightCtrl_Reposition_Response";
  }
  protected:
  explicit FlightCtrl_Reposition_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.FlightCtrl_Reposition_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class MAVLink_Generic_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.MAVLink_Generic_Request) */ {
 public:
  inline MAVLink_Generic_Request() : MAVLink_Generic_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MAVLink_Generic_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MAVLink_Generic_Request(const MAVLink_Generic_Request& from);
  MAVLink_Generic_Request(MAVLink_Generic_Request&& from) noexcept
    : MAVLink_Generic_Request() {
    *this = ::std::move(from);
  }

  inline MAVLink_Generic_Request& operator=(const MAVLink_Generic_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline MAVLink_Generic_Request& operator=(MAVLink_Generic_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MAVLink_Generic_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const MAVLink_Generic_Request* internal_default_instance() {
    return reinterpret_cast<const MAVLink_Generic_Request*>(
               &_MAVLink_Generic_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(MAVLink_Generic_Request& a, MAVLink_Generic_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(MAVLink_Generic_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MAVLink_Generic_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MAVLink_Generic_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MAVLink_Generic_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MAVLink_Generic_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MAVLink_Generic_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.MAVLink_Generic_Request";
  }
  protected:
  explicit MAVLink_Generic_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.MAVLink_Generic_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class MAVLink_Generic_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.MAVLink_Generic_Response) */ {
 public:
  inline MAVLink_Generic_Response() : MAVLink_Generic_Response(nullptr) {}
  ~MAVLink_Generic_Response() override;
  explicit PROTOBUF_CONSTEXPR MAVLink_Generic_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MAVLink_Generic_Response(const MAVLink_Generic_Response& from);
  MAVLink_Generic_Response(MAVLink_Generic_Response&& from) noexcept
    : MAVLink_Generic_Response() {
    *this = ::std::move(from);
  }

  inline MAVLink_Generic_Response& operator=(const MAVLink_Generic_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline MAVLink_Generic_Response& operator=(MAVLink_Generic_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MAVLink_Generic_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const MAVLink_Generic_Response* internal_default_instance() {
    return reinterpret_cast<const MAVLink_Generic_Response*>(
               &_MAVLink_Generic_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(MAVLink_Generic_Response& a, MAVLink_Generic_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(MAVLink_Generic_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MAVLink_Generic_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MAVLink_Generic_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MAVLink_Generic_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MAVLink_Generic_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MAVLink_Generic_Response& from) {
    MAVLink_Generic_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MAVLink_Generic_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.MAVLink_Generic_Response";
  }
  protected:
  explicit MAVLink_Generic_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMavResponseFieldNumber = 2,
    kResponseFieldNumber = 1,
  };
  // optional string mav_response = 2;
  bool has_mav_response() const;
  private:
  bool _internal_has_mav_response() const;
  public:
  void clear_mav_response();
  const std::string& mav_response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mav_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mav_response();
  PROTOBUF_NODISCARD std::string* release_mav_response();
  void set_allocated_mav_response(std::string* mav_response);
  private:
  const std::string& _internal_mav_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mav_response(const std::string& value);
  std::string* _internal_mutable_mav_response();
  public:

  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.MAVLink_Generic_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mav_response_;
    ::muas::NDNSF_Response* response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SensorCtrl_GetSensorInfo_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.SensorCtrl_GetSensorInfo_Request) */ {
 public:
  inline SensorCtrl_GetSensorInfo_Request() : SensorCtrl_GetSensorInfo_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SensorCtrl_GetSensorInfo_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorCtrl_GetSensorInfo_Request(const SensorCtrl_GetSensorInfo_Request& from);
  SensorCtrl_GetSensorInfo_Request(SensorCtrl_GetSensorInfo_Request&& from) noexcept
    : SensorCtrl_GetSensorInfo_Request() {
    *this = ::std::move(from);
  }

  inline SensorCtrl_GetSensorInfo_Request& operator=(const SensorCtrl_GetSensorInfo_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorCtrl_GetSensorInfo_Request& operator=(SensorCtrl_GetSensorInfo_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorCtrl_GetSensorInfo_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorCtrl_GetSensorInfo_Request* internal_default_instance() {
    return reinterpret_cast<const SensorCtrl_GetSensorInfo_Request*>(
               &_SensorCtrl_GetSensorInfo_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(SensorCtrl_GetSensorInfo_Request& a, SensorCtrl_GetSensorInfo_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorCtrl_GetSensorInfo_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorCtrl_GetSensorInfo_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorCtrl_GetSensorInfo_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorCtrl_GetSensorInfo_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SensorCtrl_GetSensorInfo_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SensorCtrl_GetSensorInfo_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.SensorCtrl_GetSensorInfo_Request";
  }
  protected:
  explicit SensorCtrl_GetSensorInfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.SensorCtrl_GetSensorInfo_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SensorCtrl_GetSensorInfo_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.SensorCtrl_GetSensorInfo_Response) */ {
 public:
  inline SensorCtrl_GetSensorInfo_Response() : SensorCtrl_GetSensorInfo_Response(nullptr) {}
  ~SensorCtrl_GetSensorInfo_Response() override;
  explicit PROTOBUF_CONSTEXPR SensorCtrl_GetSensorInfo_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorCtrl_GetSensorInfo_Response(const SensorCtrl_GetSensorInfo_Response& from);
  SensorCtrl_GetSensorInfo_Response(SensorCtrl_GetSensorInfo_Response&& from) noexcept
    : SensorCtrl_GetSensorInfo_Response() {
    *this = ::std::move(from);
  }

  inline SensorCtrl_GetSensorInfo_Response& operator=(const SensorCtrl_GetSensorInfo_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorCtrl_GetSensorInfo_Response& operator=(SensorCtrl_GetSensorInfo_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorCtrl_GetSensorInfo_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorCtrl_GetSensorInfo_Response* internal_default_instance() {
    return reinterpret_cast<const SensorCtrl_GetSensorInfo_Response*>(
               &_SensorCtrl_GetSensorInfo_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(SensorCtrl_GetSensorInfo_Response& a, SensorCtrl_GetSensorInfo_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorCtrl_GetSensorInfo_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorCtrl_GetSensorInfo_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorCtrl_GetSensorInfo_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorCtrl_GetSensorInfo_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorCtrl_GetSensorInfo_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorCtrl_GetSensorInfo_Response& from) {
    SensorCtrl_GetSensorInfo_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorCtrl_GetSensorInfo_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.SensorCtrl_GetSensorInfo_Response";
  }
  protected:
  explicit SensorCtrl_GetSensorInfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorsFieldNumber = 2,
    kResponseFieldNumber = 1,
  };
  // repeated .muas.Sensor sensors = 2;
  int sensors_size() const;
  private:
  int _internal_sensors_size() const;
  public:
  void clear_sensors();
  ::muas::Sensor* mutable_sensors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::muas::Sensor >*
      mutable_sensors();
  private:
  const ::muas::Sensor& _internal_sensors(int index) const;
  ::muas::Sensor* _internal_add_sensors();
  public:
  const ::muas::Sensor& sensors(int index) const;
  ::muas::Sensor* add_sensors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::muas::Sensor >&
      sensors() const;

  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.SensorCtrl_GetSensorInfo_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::muas::Sensor > sensors_;
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SensorCtrl_CaptureSingle_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:muas.SensorCtrl_CaptureSingle_Request) */ {
 public:
  inline SensorCtrl_CaptureSingle_Request() : SensorCtrl_CaptureSingle_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SensorCtrl_CaptureSingle_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorCtrl_CaptureSingle_Request(const SensorCtrl_CaptureSingle_Request& from);
  SensorCtrl_CaptureSingle_Request(SensorCtrl_CaptureSingle_Request&& from) noexcept
    : SensorCtrl_CaptureSingle_Request() {
    *this = ::std::move(from);
  }

  inline SensorCtrl_CaptureSingle_Request& operator=(const SensorCtrl_CaptureSingle_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorCtrl_CaptureSingle_Request& operator=(SensorCtrl_CaptureSingle_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorCtrl_CaptureSingle_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorCtrl_CaptureSingle_Request* internal_default_instance() {
    return reinterpret_cast<const SensorCtrl_CaptureSingle_Request*>(
               &_SensorCtrl_CaptureSingle_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(SensorCtrl_CaptureSingle_Request& a, SensorCtrl_CaptureSingle_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorCtrl_CaptureSingle_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorCtrl_CaptureSingle_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorCtrl_CaptureSingle_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorCtrl_CaptureSingle_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SensorCtrl_CaptureSingle_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SensorCtrl_CaptureSingle_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.SensorCtrl_CaptureSingle_Request";
  }
  protected:
  explicit SensorCtrl_CaptureSingle_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:muas.SensorCtrl_CaptureSingle_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SensorCtrl_CaptureSingle_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.SensorCtrl_CaptureSingle_Response) */ {
 public:
  inline SensorCtrl_CaptureSingle_Response() : SensorCtrl_CaptureSingle_Response(nullptr) {}
  ~SensorCtrl_CaptureSingle_Response() override;
  explicit PROTOBUF_CONSTEXPR SensorCtrl_CaptureSingle_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorCtrl_CaptureSingle_Response(const SensorCtrl_CaptureSingle_Response& from);
  SensorCtrl_CaptureSingle_Response(SensorCtrl_CaptureSingle_Response&& from) noexcept
    : SensorCtrl_CaptureSingle_Response() {
    *this = ::std::move(from);
  }

  inline SensorCtrl_CaptureSingle_Response& operator=(const SensorCtrl_CaptureSingle_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorCtrl_CaptureSingle_Response& operator=(SensorCtrl_CaptureSingle_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorCtrl_CaptureSingle_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorCtrl_CaptureSingle_Response* internal_default_instance() {
    return reinterpret_cast<const SensorCtrl_CaptureSingle_Response*>(
               &_SensorCtrl_CaptureSingle_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(SensorCtrl_CaptureSingle_Response& a, SensorCtrl_CaptureSingle_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorCtrl_CaptureSingle_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorCtrl_CaptureSingle_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorCtrl_CaptureSingle_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorCtrl_CaptureSingle_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorCtrl_CaptureSingle_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorCtrl_CaptureSingle_Response& from) {
    SensorCtrl_CaptureSingle_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorCtrl_CaptureSingle_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.SensorCtrl_CaptureSingle_Response";
  }
  protected:
  explicit SensorCtrl_CaptureSingle_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCaptureIdFieldNumber = 2,
    kResponseFieldNumber = 1,
  };
  // string capture_id = 2;
  void clear_capture_id();
  const std::string& capture_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_capture_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_capture_id();
  PROTOBUF_NODISCARD std::string* release_capture_id();
  void set_allocated_capture_id(std::string* capture_id);
  private:
  const std::string& _internal_capture_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_capture_id(const std::string& value);
  std::string* _internal_mutable_capture_id();
  public:

  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.SensorCtrl_CaptureSingle_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr capture_id_;
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SensorCtrl_CapturePeriodic_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.SensorCtrl_CapturePeriodic_Request) */ {
 public:
  inline SensorCtrl_CapturePeriodic_Request() : SensorCtrl_CapturePeriodic_Request(nullptr) {}
  ~SensorCtrl_CapturePeriodic_Request() override;
  explicit PROTOBUF_CONSTEXPR SensorCtrl_CapturePeriodic_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorCtrl_CapturePeriodic_Request(const SensorCtrl_CapturePeriodic_Request& from);
  SensorCtrl_CapturePeriodic_Request(SensorCtrl_CapturePeriodic_Request&& from) noexcept
    : SensorCtrl_CapturePeriodic_Request() {
    *this = ::std::move(from);
  }

  inline SensorCtrl_CapturePeriodic_Request& operator=(const SensorCtrl_CapturePeriodic_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorCtrl_CapturePeriodic_Request& operator=(SensorCtrl_CapturePeriodic_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorCtrl_CapturePeriodic_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorCtrl_CapturePeriodic_Request* internal_default_instance() {
    return reinterpret_cast<const SensorCtrl_CapturePeriodic_Request*>(
               &_SensorCtrl_CapturePeriodic_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(SensorCtrl_CapturePeriodic_Request& a, SensorCtrl_CapturePeriodic_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorCtrl_CapturePeriodic_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorCtrl_CapturePeriodic_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorCtrl_CapturePeriodic_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorCtrl_CapturePeriodic_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorCtrl_CapturePeriodic_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorCtrl_CapturePeriodic_Request& from) {
    SensorCtrl_CapturePeriodic_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorCtrl_CapturePeriodic_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.SensorCtrl_CapturePeriodic_Request";
  }
  protected:
  explicit SensorCtrl_CapturePeriodic_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalSecFieldNumber = 1,
  };
  // int32 interval_sec = 1;
  void clear_interval_sec();
  int32_t interval_sec() const;
  void set_interval_sec(int32_t value);
  private:
  int32_t _internal_interval_sec() const;
  void _internal_set_interval_sec(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:muas.SensorCtrl_CapturePeriodic_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t interval_sec_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SensorCtrl_CapturePeriodic_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:muas.SensorCtrl_CapturePeriodic_Response) */ {
 public:
  inline SensorCtrl_CapturePeriodic_Response() : SensorCtrl_CapturePeriodic_Response(nullptr) {}
  ~SensorCtrl_CapturePeriodic_Response() override;
  explicit PROTOBUF_CONSTEXPR SensorCtrl_CapturePeriodic_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorCtrl_CapturePeriodic_Response(const SensorCtrl_CapturePeriodic_Response& from);
  SensorCtrl_CapturePeriodic_Response(SensorCtrl_CapturePeriodic_Response&& from) noexcept
    : SensorCtrl_CapturePeriodic_Response() {
    *this = ::std::move(from);
  }

  inline SensorCtrl_CapturePeriodic_Response& operator=(const SensorCtrl_CapturePeriodic_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorCtrl_CapturePeriodic_Response& operator=(SensorCtrl_CapturePeriodic_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorCtrl_CapturePeriodic_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorCtrl_CapturePeriodic_Response* internal_default_instance() {
    return reinterpret_cast<const SensorCtrl_CapturePeriodic_Response*>(
               &_SensorCtrl_CapturePeriodic_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(SensorCtrl_CapturePeriodic_Response& a, SensorCtrl_CapturePeriodic_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorCtrl_CapturePeriodic_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorCtrl_CapturePeriodic_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorCtrl_CapturePeriodic_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorCtrl_CapturePeriodic_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorCtrl_CapturePeriodic_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorCtrl_CapturePeriodic_Response& from) {
    SensorCtrl_CapturePeriodic_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorCtrl_CapturePeriodic_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "muas.SensorCtrl_CapturePeriodic_Response";
  }
  protected:
  explicit SensorCtrl_CapturePeriodic_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCaptureIdFieldNumber = 2,
    kResponseFieldNumber = 1,
  };
  // string capture_id = 2;
  void clear_capture_id();
  const std::string& capture_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_capture_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_capture_id();
  PROTOBUF_NODISCARD std::string* release_capture_id();
  void set_allocated_capture_id(std::string* capture_id);
  private:
  const std::string& _internal_capture_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_capture_id(const std::string& value);
  std::string* _internal_mutable_capture_id();
  public:

  // .muas.NDNSF_Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::muas::NDNSF_Response& response() const;
  PROTOBUF_NODISCARD ::muas::NDNSF_Response* release_response();
  ::muas::NDNSF_Response* mutable_response();
  void set_allocated_response(::muas::NDNSF_Response* response);
  private:
  const ::muas::NDNSF_Response& _internal_response() const;
  ::muas::NDNSF_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::muas::NDNSF_Response* response);
  ::muas::NDNSF_Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:muas.SensorCtrl_CapturePeriodic_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr capture_id_;
    ::muas::NDNSF_Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Position

// float latitude = 1;
inline void Position::clear_latitude() {
  _impl_.latitude_ = 0;
}
inline float Position::_internal_latitude() const {
  return _impl_.latitude_;
}
inline float Position::latitude() const {
  // @@protoc_insertion_point(field_get:muas.Position.latitude)
  return _internal_latitude();
}
inline void Position::_internal_set_latitude(float value) {
  
  _impl_.latitude_ = value;
}
inline void Position::set_latitude(float value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:muas.Position.latitude)
}

// float longitude = 2;
inline void Position::clear_longitude() {
  _impl_.longitude_ = 0;
}
inline float Position::_internal_longitude() const {
  return _impl_.longitude_;
}
inline float Position::longitude() const {
  // @@protoc_insertion_point(field_get:muas.Position.longitude)
  return _internal_longitude();
}
inline void Position::_internal_set_longitude(float value) {
  
  _impl_.longitude_ = value;
}
inline void Position::set_longitude(float value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:muas.Position.longitude)
}

// float altitude = 3;
inline void Position::clear_altitude() {
  _impl_.altitude_ = 0;
}
inline float Position::_internal_altitude() const {
  return _impl_.altitude_;
}
inline float Position::altitude() const {
  // @@protoc_insertion_point(field_get:muas.Position.altitude)
  return _internal_altitude();
}
inline void Position::_internal_set_altitude(float value) {
  
  _impl_.altitude_ = value;
}
inline void Position::set_altitude(float value) {
  _internal_set_altitude(value);
  // @@protoc_insertion_point(field_set:muas.Position.altitude)
}

// -------------------------------------------------------------------

// Orientation

// float yaw = 1;
inline void Orientation::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float Orientation::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float Orientation::yaw() const {
  // @@protoc_insertion_point(field_get:muas.Orientation.yaw)
  return _internal_yaw();
}
inline void Orientation::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void Orientation::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:muas.Orientation.yaw)
}

// float pitch = 2;
inline void Orientation::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float Orientation::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float Orientation::pitch() const {
  // @@protoc_insertion_point(field_get:muas.Orientation.pitch)
  return _internal_pitch();
}
inline void Orientation::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void Orientation::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:muas.Orientation.pitch)
}

// float roll = 3;
inline void Orientation::clear_roll() {
  _impl_.roll_ = 0;
}
inline float Orientation::_internal_roll() const {
  return _impl_.roll_;
}
inline float Orientation::roll() const {
  // @@protoc_insertion_point(field_get:muas.Orientation.roll)
  return _internal_roll();
}
inline void Orientation::_internal_set_roll(float value) {
  
  _impl_.roll_ = value;
}
inline void Orientation::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:muas.Orientation.roll)
}

// -------------------------------------------------------------------

// MissionItem

// int32 target_sys = 1;
inline void MissionItem::clear_target_sys() {
  _impl_.target_sys_ = 0;
}
inline int32_t MissionItem::_internal_target_sys() const {
  return _impl_.target_sys_;
}
inline int32_t MissionItem::target_sys() const {
  // @@protoc_insertion_point(field_get:muas.MissionItem.target_sys)
  return _internal_target_sys();
}
inline void MissionItem::_internal_set_target_sys(int32_t value) {
  
  _impl_.target_sys_ = value;
}
inline void MissionItem::set_target_sys(int32_t value) {
  _internal_set_target_sys(value);
  // @@protoc_insertion_point(field_set:muas.MissionItem.target_sys)
}

// int32 target_comp = 2;
inline void MissionItem::clear_target_comp() {
  _impl_.target_comp_ = 0;
}
inline int32_t MissionItem::_internal_target_comp() const {
  return _impl_.target_comp_;
}
inline int32_t MissionItem::target_comp() const {
  // @@protoc_insertion_point(field_get:muas.MissionItem.target_comp)
  return _internal_target_comp();
}
inline void MissionItem::_internal_set_target_comp(int32_t value) {
  
  _impl_.target_comp_ = value;
}
inline void MissionItem::set_target_comp(int32_t value) {
  _internal_set_target_comp(value);
  // @@protoc_insertion_point(field_set:muas.MissionItem.target_comp)
}

// int32 seq = 3;
inline void MissionItem::clear_seq() {
  _impl_.seq_ = 0;
}
inline int32_t MissionItem::_internal_seq() const {
  return _impl_.seq_;
}
inline int32_t MissionItem::seq() const {
  // @@protoc_insertion_point(field_get:muas.MissionItem.seq)
  return _internal_seq();
}
inline void MissionItem::_internal_set_seq(int32_t value) {
  
  _impl_.seq_ = value;
}
inline void MissionItem::set_seq(int32_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:muas.MissionItem.seq)
}

// .muas.MissionItem.Frame frame = 4;
inline void MissionItem::clear_frame() {
  _impl_.frame_ = 0;
}
inline ::muas::MissionItem_Frame MissionItem::_internal_frame() const {
  return static_cast< ::muas::MissionItem_Frame >(_impl_.frame_);
}
inline ::muas::MissionItem_Frame MissionItem::frame() const {
  // @@protoc_insertion_point(field_get:muas.MissionItem.frame)
  return _internal_frame();
}
inline void MissionItem::_internal_set_frame(::muas::MissionItem_Frame value) {
  
  _impl_.frame_ = value;
}
inline void MissionItem::set_frame(::muas::MissionItem_Frame value) {
  _internal_set_frame(value);
  // @@protoc_insertion_point(field_set:muas.MissionItem.frame)
}

// .muas.MissionItem.MAV_CMD cmd = 5;
inline void MissionItem::clear_cmd() {
  _impl_.cmd_ = 0;
}
inline ::muas::MissionItem_MAV_CMD MissionItem::_internal_cmd() const {
  return static_cast< ::muas::MissionItem_MAV_CMD >(_impl_.cmd_);
}
inline ::muas::MissionItem_MAV_CMD MissionItem::cmd() const {
  // @@protoc_insertion_point(field_get:muas.MissionItem.cmd)
  return _internal_cmd();
}
inline void MissionItem::_internal_set_cmd(::muas::MissionItem_MAV_CMD value) {
  
  _impl_.cmd_ = value;
}
inline void MissionItem::set_cmd(::muas::MissionItem_MAV_CMD value) {
  _internal_set_cmd(value);
  // @@protoc_insertion_point(field_set:muas.MissionItem.cmd)
}

// bool current = 6;
inline void MissionItem::clear_current() {
  _impl_.current_ = false;
}
inline bool MissionItem::_internal_current() const {
  return _impl_.current_;
}
inline bool MissionItem::current() const {
  // @@protoc_insertion_point(field_get:muas.MissionItem.current)
  return _internal_current();
}
inline void MissionItem::_internal_set_current(bool value) {
  
  _impl_.current_ = value;
}
inline void MissionItem::set_current(bool value) {
  _internal_set_current(value);
  // @@protoc_insertion_point(field_set:muas.MissionItem.current)
}

// bool autocontinue = 7;
inline void MissionItem::clear_autocontinue() {
  _impl_.autocontinue_ = false;
}
inline bool MissionItem::_internal_autocontinue() const {
  return _impl_.autocontinue_;
}
inline bool MissionItem::autocontinue() const {
  // @@protoc_insertion_point(field_get:muas.MissionItem.autocontinue)
  return _internal_autocontinue();
}
inline void MissionItem::_internal_set_autocontinue(bool value) {
  
  _impl_.autocontinue_ = value;
}
inline void MissionItem::set_autocontinue(bool value) {
  _internal_set_autocontinue(value);
  // @@protoc_insertion_point(field_set:muas.MissionItem.autocontinue)
}

// float param1 = 8;
inline void MissionItem::clear_param1() {
  _impl_.param1_ = 0;
}
inline float MissionItem::_internal_param1() const {
  return _impl_.param1_;
}
inline float MissionItem::param1() const {
  // @@protoc_insertion_point(field_get:muas.MissionItem.param1)
  return _internal_param1();
}
inline void MissionItem::_internal_set_param1(float value) {
  
  _impl_.param1_ = value;
}
inline void MissionItem::set_param1(float value) {
  _internal_set_param1(value);
  // @@protoc_insertion_point(field_set:muas.MissionItem.param1)
}

// float param2 = 9;
inline void MissionItem::clear_param2() {
  _impl_.param2_ = 0;
}
inline float MissionItem::_internal_param2() const {
  return _impl_.param2_;
}
inline float MissionItem::param2() const {
  // @@protoc_insertion_point(field_get:muas.MissionItem.param2)
  return _internal_param2();
}
inline void MissionItem::_internal_set_param2(float value) {
  
  _impl_.param2_ = value;
}
inline void MissionItem::set_param2(float value) {
  _internal_set_param2(value);
  // @@protoc_insertion_point(field_set:muas.MissionItem.param2)
}

// float param3 = 10;
inline void MissionItem::clear_param3() {
  _impl_.param3_ = 0;
}
inline float MissionItem::_internal_param3() const {
  return _impl_.param3_;
}
inline float MissionItem::param3() const {
  // @@protoc_insertion_point(field_get:muas.MissionItem.param3)
  return _internal_param3();
}
inline void MissionItem::_internal_set_param3(float value) {
  
  _impl_.param3_ = value;
}
inline void MissionItem::set_param3(float value) {
  _internal_set_param3(value);
  // @@protoc_insertion_point(field_set:muas.MissionItem.param3)
}

// float param4 = 11;
inline void MissionItem::clear_param4() {
  _impl_.param4_ = 0;
}
inline float MissionItem::_internal_param4() const {
  return _impl_.param4_;
}
inline float MissionItem::param4() const {
  // @@protoc_insertion_point(field_get:muas.MissionItem.param4)
  return _internal_param4();
}
inline void MissionItem::_internal_set_param4(float value) {
  
  _impl_.param4_ = value;
}
inline void MissionItem::set_param4(float value) {
  _internal_set_param4(value);
  // @@protoc_insertion_point(field_set:muas.MissionItem.param4)
}

// int32 x = 12;
inline void MissionItem::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t MissionItem::_internal_x() const {
  return _impl_.x_;
}
inline int32_t MissionItem::x() const {
  // @@protoc_insertion_point(field_get:muas.MissionItem.x)
  return _internal_x();
}
inline void MissionItem::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void MissionItem::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:muas.MissionItem.x)
}

// int32 y = 13;
inline void MissionItem::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t MissionItem::_internal_y() const {
  return _impl_.y_;
}
inline int32_t MissionItem::y() const {
  // @@protoc_insertion_point(field_get:muas.MissionItem.y)
  return _internal_y();
}
inline void MissionItem::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void MissionItem::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:muas.MissionItem.y)
}

// int32 z = 14;
inline void MissionItem::clear_z() {
  _impl_.z_ = 0;
}
inline int32_t MissionItem::_internal_z() const {
  return _impl_.z_;
}
inline int32_t MissionItem::z() const {
  // @@protoc_insertion_point(field_get:muas.MissionItem.z)
  return _internal_z();
}
inline void MissionItem::_internal_set_z(int32_t value) {
  
  _impl_.z_ = value;
}
inline void MissionItem::set_z(int32_t value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:muas.MissionItem.z)
}

// -------------------------------------------------------------------

// MissionInfo

// int32 num_items = 1;
inline void MissionInfo::clear_num_items() {
  _impl_.num_items_ = 0;
}
inline int32_t MissionInfo::_internal_num_items() const {
  return _impl_.num_items_;
}
inline int32_t MissionInfo::num_items() const {
  // @@protoc_insertion_point(field_get:muas.MissionInfo.num_items)
  return _internal_num_items();
}
inline void MissionInfo::_internal_set_num_items(int32_t value) {
  
  _impl_.num_items_ = value;
}
inline void MissionInfo::set_num_items(int32_t value) {
  _internal_set_num_items(value);
  // @@protoc_insertion_point(field_set:muas.MissionInfo.num_items)
}

// -------------------------------------------------------------------

// Sensor

// string name = 1;
inline void Sensor::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Sensor::name() const {
  // @@protoc_insertion_point(field_get:muas.Sensor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sensor::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:muas.Sensor.name)
}
inline std::string* Sensor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:muas.Sensor.name)
  return _s;
}
inline const std::string& Sensor::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Sensor::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Sensor::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Sensor::release_name() {
  // @@protoc_insertion_point(field_release:muas.Sensor.name)
  return _impl_.name_.Release();
}
inline void Sensor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:muas.Sensor.name)
}

// int32 id = 2;
inline void Sensor::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Sensor::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Sensor::id() const {
  // @@protoc_insertion_point(field_get:muas.Sensor.id)
  return _internal_id();
}
inline void Sensor::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Sensor::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:muas.Sensor.id)
}

// .muas.Sensor.SensorType type = 3;
inline void Sensor::clear_type() {
  _impl_.type_ = 0;
}
inline ::muas::Sensor_SensorType Sensor::_internal_type() const {
  return static_cast< ::muas::Sensor_SensorType >(_impl_.type_);
}
inline ::muas::Sensor_SensorType Sensor::type() const {
  // @@protoc_insertion_point(field_get:muas.Sensor.type)
  return _internal_type();
}
inline void Sensor::_internal_set_type(::muas::Sensor_SensorType value) {
  
  _impl_.type_ = value;
}
inline void Sensor::set_type(::muas::Sensor_SensorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:muas.Sensor.type)
}

// string data_namespace = 4;
inline void Sensor::clear_data_namespace() {
  _impl_.data_namespace_.ClearToEmpty();
}
inline const std::string& Sensor::data_namespace() const {
  // @@protoc_insertion_point(field_get:muas.Sensor.data_namespace)
  return _internal_data_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sensor::set_data_namespace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:muas.Sensor.data_namespace)
}
inline std::string* Sensor::mutable_data_namespace() {
  std::string* _s = _internal_mutable_data_namespace();
  // @@protoc_insertion_point(field_mutable:muas.Sensor.data_namespace)
  return _s;
}
inline const std::string& Sensor::_internal_data_namespace() const {
  return _impl_.data_namespace_.Get();
}
inline void Sensor::_internal_set_data_namespace(const std::string& value) {
  
  _impl_.data_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* Sensor::_internal_mutable_data_namespace() {
  
  return _impl_.data_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* Sensor::release_data_namespace() {
  // @@protoc_insertion_point(field_release:muas.Sensor.data_namespace)
  return _impl_.data_namespace_.Release();
}
inline void Sensor::set_allocated_data_namespace(std::string* data_namespace) {
  if (data_namespace != nullptr) {
    
  } else {
    
  }
  _impl_.data_namespace_.SetAllocated(data_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_namespace_.IsDefault()) {
    _impl_.data_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:muas.Sensor.data_namespace)
}

// -------------------------------------------------------------------

// NDNSF_Response

// .muas.NDNSF_Response.miniMUAS_Code code = 1;
inline void NDNSF_Response::clear_code() {
  _impl_.code_ = 0;
}
inline ::muas::NDNSF_Response_miniMUAS_Code NDNSF_Response::_internal_code() const {
  return static_cast< ::muas::NDNSF_Response_miniMUAS_Code >(_impl_.code_);
}
inline ::muas::NDNSF_Response_miniMUAS_Code NDNSF_Response::code() const {
  // @@protoc_insertion_point(field_get:muas.NDNSF_Response.code)
  return _internal_code();
}
inline void NDNSF_Response::_internal_set_code(::muas::NDNSF_Response_miniMUAS_Code value) {
  
  _impl_.code_ = value;
}
inline void NDNSF_Response::set_code(::muas::NDNSF_Response_miniMUAS_Code value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:muas.NDNSF_Response.code)
}

// optional string msg = 2;
inline bool NDNSF_Response::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NDNSF_Response::has_msg() const {
  return _internal_has_msg();
}
inline void NDNSF_Response::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NDNSF_Response::msg() const {
  // @@protoc_insertion_point(field_get:muas.NDNSF_Response.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NDNSF_Response::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:muas.NDNSF_Response.msg)
}
inline std::string* NDNSF_Response::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:muas.NDNSF_Response.msg)
  return _s;
}
inline const std::string& NDNSF_Response::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void NDNSF_Response::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* NDNSF_Response::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* NDNSF_Response::release_msg() {
  // @@protoc_insertion_point(field_release:muas.NDNSF_Response.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NDNSF_Response::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:muas.NDNSF_Response.msg)
}

// -------------------------------------------------------------------

// Entity_Echo_Request

// string nonce = 1;
inline void Entity_Echo_Request::clear_nonce() {
  _impl_.nonce_.ClearToEmpty();
}
inline const std::string& Entity_Echo_Request::nonce() const {
  // @@protoc_insertion_point(field_get:muas.Entity_Echo_Request.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Entity_Echo_Request::set_nonce(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nonce_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:muas.Entity_Echo_Request.nonce)
}
inline std::string* Entity_Echo_Request::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:muas.Entity_Echo_Request.nonce)
  return _s;
}
inline const std::string& Entity_Echo_Request::_internal_nonce() const {
  return _impl_.nonce_.Get();
}
inline void Entity_Echo_Request::_internal_set_nonce(const std::string& value) {
  
  _impl_.nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* Entity_Echo_Request::_internal_mutable_nonce() {
  
  return _impl_.nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* Entity_Echo_Request::release_nonce() {
  // @@protoc_insertion_point(field_release:muas.Entity_Echo_Request.nonce)
  return _impl_.nonce_.Release();
}
inline void Entity_Echo_Request::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  _impl_.nonce_.SetAllocated(nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nonce_.IsDefault()) {
    _impl_.nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:muas.Entity_Echo_Request.nonce)
}

// -------------------------------------------------------------------

// Entity_Echo_Response

// string nonce = 1;
inline void Entity_Echo_Response::clear_nonce() {
  _impl_.nonce_.ClearToEmpty();
}
inline const std::string& Entity_Echo_Response::nonce() const {
  // @@protoc_insertion_point(field_get:muas.Entity_Echo_Response.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Entity_Echo_Response::set_nonce(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nonce_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:muas.Entity_Echo_Response.nonce)
}
inline std::string* Entity_Echo_Response::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:muas.Entity_Echo_Response.nonce)
  return _s;
}
inline const std::string& Entity_Echo_Response::_internal_nonce() const {
  return _impl_.nonce_.Get();
}
inline void Entity_Echo_Response::_internal_set_nonce(const std::string& value) {
  
  _impl_.nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* Entity_Echo_Response::_internal_mutable_nonce() {
  
  return _impl_.nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* Entity_Echo_Response::release_nonce() {
  // @@protoc_insertion_point(field_release:muas.Entity_Echo_Response.nonce)
  return _impl_.nonce_.Release();
}
inline void Entity_Echo_Response::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  _impl_.nonce_.SetAllocated(nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nonce_.IsDefault()) {
    _impl_.nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:muas.Entity_Echo_Response.nonce)
}

// -------------------------------------------------------------------

// Entity_GetEntityInfo_Request

// .muas.NDNSF_Response response = 1;
inline bool Entity_GetEntityInfo_Request::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Entity_GetEntityInfo_Request::has_response() const {
  return _internal_has_response();
}
inline void Entity_GetEntityInfo_Request::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& Entity_GetEntityInfo_Request::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& Entity_GetEntityInfo_Request::response() const {
  // @@protoc_insertion_point(field_get:muas.Entity_GetEntityInfo_Request.response)
  return _internal_response();
}
inline void Entity_GetEntityInfo_Request::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Entity_GetEntityInfo_Request.response)
}
inline ::muas::NDNSF_Response* Entity_GetEntityInfo_Request::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* Entity_GetEntityInfo_Request::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.Entity_GetEntityInfo_Request.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* Entity_GetEntityInfo_Request::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* Entity_GetEntityInfo_Request::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.Entity_GetEntityInfo_Request.response)
  return _msg;
}
inline void Entity_GetEntityInfo_Request::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.Entity_GetEntityInfo_Request.response)
}

// int32 key = 2;
inline void Entity_GetEntityInfo_Request::clear_key() {
  _impl_.key_ = 0;
}
inline int32_t Entity_GetEntityInfo_Request::_internal_key() const {
  return _impl_.key_;
}
inline int32_t Entity_GetEntityInfo_Request::key() const {
  // @@protoc_insertion_point(field_get:muas.Entity_GetEntityInfo_Request.key)
  return _internal_key();
}
inline void Entity_GetEntityInfo_Request::_internal_set_key(int32_t value) {
  
  _impl_.key_ = value;
}
inline void Entity_GetEntityInfo_Request::set_key(int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:muas.Entity_GetEntityInfo_Request.key)
}

// -------------------------------------------------------------------

// Entity_GetEntityInfo_Response

// .muas.NDNSF_Response response = 1;
inline bool Entity_GetEntityInfo_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Entity_GetEntityInfo_Response::has_response() const {
  return _internal_has_response();
}
inline void Entity_GetEntityInfo_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& Entity_GetEntityInfo_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& Entity_GetEntityInfo_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.Entity_GetEntityInfo_Response.response)
  return _internal_response();
}
inline void Entity_GetEntityInfo_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Entity_GetEntityInfo_Response.response)
}
inline ::muas::NDNSF_Response* Entity_GetEntityInfo_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* Entity_GetEntityInfo_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.Entity_GetEntityInfo_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* Entity_GetEntityInfo_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* Entity_GetEntityInfo_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.Entity_GetEntityInfo_Response.response)
  return _msg;
}
inline void Entity_GetEntityInfo_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.Entity_GetEntityInfo_Response.response)
}

// string value = 2;
inline void Entity_GetEntityInfo_Response::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Entity_GetEntityInfo_Response::value() const {
  // @@protoc_insertion_point(field_get:muas.Entity_GetEntityInfo_Response.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Entity_GetEntityInfo_Response::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:muas.Entity_GetEntityInfo_Response.value)
}
inline std::string* Entity_GetEntityInfo_Response::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:muas.Entity_GetEntityInfo_Response.value)
  return _s;
}
inline const std::string& Entity_GetEntityInfo_Response::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Entity_GetEntityInfo_Response::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Entity_GetEntityInfo_Response::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Entity_GetEntityInfo_Response::release_value() {
  // @@protoc_insertion_point(field_release:muas.Entity_GetEntityInfo_Response.value)
  return _impl_.value_.Release();
}
inline void Entity_GetEntityInfo_Response::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:muas.Entity_GetEntityInfo_Response.value)
}

// -------------------------------------------------------------------

// Entity_GetPosition_Request

// -------------------------------------------------------------------

// Entity_GetPosition_Response

// .muas.NDNSF_Response response = 1;
inline bool Entity_GetPosition_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Entity_GetPosition_Response::has_response() const {
  return _internal_has_response();
}
inline void Entity_GetPosition_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& Entity_GetPosition_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& Entity_GetPosition_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.Entity_GetPosition_Response.response)
  return _internal_response();
}
inline void Entity_GetPosition_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Entity_GetPosition_Response.response)
}
inline ::muas::NDNSF_Response* Entity_GetPosition_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* Entity_GetPosition_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.Entity_GetPosition_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* Entity_GetPosition_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* Entity_GetPosition_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.Entity_GetPosition_Response.response)
  return _msg;
}
inline void Entity_GetPosition_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.Entity_GetPosition_Response.response)
}

// .muas.Position pos = 2;
inline bool Entity_GetPosition_Response::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Entity_GetPosition_Response::has_pos() const {
  return _internal_has_pos();
}
inline void Entity_GetPosition_Response::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::muas::Position& Entity_GetPosition_Response::_internal_pos() const {
  const ::muas::Position* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::Position&>(
      ::muas::_Position_default_instance_);
}
inline const ::muas::Position& Entity_GetPosition_Response::pos() const {
  // @@protoc_insertion_point(field_get:muas.Entity_GetPosition_Response.pos)
  return _internal_pos();
}
inline void Entity_GetPosition_Response::unsafe_arena_set_allocated_pos(
    ::muas::Position* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Entity_GetPosition_Response.pos)
}
inline ::muas::Position* Entity_GetPosition_Response::release_pos() {
  
  ::muas::Position* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::Position* Entity_GetPosition_Response::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:muas.Entity_GetPosition_Response.pos)
  
  ::muas::Position* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::muas::Position* Entity_GetPosition_Response::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::Position>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::muas::Position* Entity_GetPosition_Response::mutable_pos() {
  ::muas::Position* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:muas.Entity_GetPosition_Response.pos)
  return _msg;
}
inline void Entity_GetPosition_Response::set_allocated_pos(::muas::Position* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:muas.Entity_GetPosition_Response.pos)
}

// -------------------------------------------------------------------

// Entity_GetOrientation_Request

// -------------------------------------------------------------------

// Entity_GetOrientation_Response

// .muas.NDNSF_Response response = 1;
inline bool Entity_GetOrientation_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Entity_GetOrientation_Response::has_response() const {
  return _internal_has_response();
}
inline void Entity_GetOrientation_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& Entity_GetOrientation_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& Entity_GetOrientation_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.Entity_GetOrientation_Response.response)
  return _internal_response();
}
inline void Entity_GetOrientation_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Entity_GetOrientation_Response.response)
}
inline ::muas::NDNSF_Response* Entity_GetOrientation_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* Entity_GetOrientation_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.Entity_GetOrientation_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* Entity_GetOrientation_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* Entity_GetOrientation_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.Entity_GetOrientation_Response.response)
  return _msg;
}
inline void Entity_GetOrientation_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.Entity_GetOrientation_Response.response)
}

// .muas.Orientation attitude = 2;
inline bool Entity_GetOrientation_Response::_internal_has_attitude() const {
  return this != internal_default_instance() && _impl_.attitude_ != nullptr;
}
inline bool Entity_GetOrientation_Response::has_attitude() const {
  return _internal_has_attitude();
}
inline void Entity_GetOrientation_Response::clear_attitude() {
  if (GetArenaForAllocation() == nullptr && _impl_.attitude_ != nullptr) {
    delete _impl_.attitude_;
  }
  _impl_.attitude_ = nullptr;
}
inline const ::muas::Orientation& Entity_GetOrientation_Response::_internal_attitude() const {
  const ::muas::Orientation* p = _impl_.attitude_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::Orientation&>(
      ::muas::_Orientation_default_instance_);
}
inline const ::muas::Orientation& Entity_GetOrientation_Response::attitude() const {
  // @@protoc_insertion_point(field_get:muas.Entity_GetOrientation_Response.attitude)
  return _internal_attitude();
}
inline void Entity_GetOrientation_Response::unsafe_arena_set_allocated_attitude(
    ::muas::Orientation* attitude) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attitude_);
  }
  _impl_.attitude_ = attitude;
  if (attitude) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Entity_GetOrientation_Response.attitude)
}
inline ::muas::Orientation* Entity_GetOrientation_Response::release_attitude() {
  
  ::muas::Orientation* temp = _impl_.attitude_;
  _impl_.attitude_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::Orientation* Entity_GetOrientation_Response::unsafe_arena_release_attitude() {
  // @@protoc_insertion_point(field_release:muas.Entity_GetOrientation_Response.attitude)
  
  ::muas::Orientation* temp = _impl_.attitude_;
  _impl_.attitude_ = nullptr;
  return temp;
}
inline ::muas::Orientation* Entity_GetOrientation_Response::_internal_mutable_attitude() {
  
  if (_impl_.attitude_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::Orientation>(GetArenaForAllocation());
    _impl_.attitude_ = p;
  }
  return _impl_.attitude_;
}
inline ::muas::Orientation* Entity_GetOrientation_Response::mutable_attitude() {
  ::muas::Orientation* _msg = _internal_mutable_attitude();
  // @@protoc_insertion_point(field_mutable:muas.Entity_GetOrientation_Response.attitude)
  return _msg;
}
inline void Entity_GetOrientation_Response::set_allocated_attitude(::muas::Orientation* attitude) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attitude_;
  }
  if (attitude) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attitude);
    if (message_arena != submessage_arena) {
      attitude = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attitude, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attitude_ = attitude;
  // @@protoc_insertion_point(field_set_allocated:muas.Entity_GetOrientation_Response.attitude)
}

// -------------------------------------------------------------------

// Admin_Test_Request

// -------------------------------------------------------------------

// Admin_Test_Response

// .muas.NDNSF_Response response = 1;
inline bool Admin_Test_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Admin_Test_Response::has_response() const {
  return _internal_has_response();
}
inline void Admin_Test_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& Admin_Test_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& Admin_Test_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.Admin_Test_Response.response)
  return _internal_response();
}
inline void Admin_Test_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Admin_Test_Response.response)
}
inline ::muas::NDNSF_Response* Admin_Test_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* Admin_Test_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.Admin_Test_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* Admin_Test_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* Admin_Test_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.Admin_Test_Response.response)
  return _msg;
}
inline void Admin_Test_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.Admin_Test_Response.response)
}

// string reply = 2;
inline void Admin_Test_Response::clear_reply() {
  _impl_.reply_.ClearToEmpty();
}
inline const std::string& Admin_Test_Response::reply() const {
  // @@protoc_insertion_point(field_get:muas.Admin_Test_Response.reply)
  return _internal_reply();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Admin_Test_Response::set_reply(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reply_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:muas.Admin_Test_Response.reply)
}
inline std::string* Admin_Test_Response::mutable_reply() {
  std::string* _s = _internal_mutable_reply();
  // @@protoc_insertion_point(field_mutable:muas.Admin_Test_Response.reply)
  return _s;
}
inline const std::string& Admin_Test_Response::_internal_reply() const {
  return _impl_.reply_.Get();
}
inline void Admin_Test_Response::_internal_set_reply(const std::string& value) {
  
  _impl_.reply_.Set(value, GetArenaForAllocation());
}
inline std::string* Admin_Test_Response::_internal_mutable_reply() {
  
  return _impl_.reply_.Mutable(GetArenaForAllocation());
}
inline std::string* Admin_Test_Response::release_reply() {
  // @@protoc_insertion_point(field_release:muas.Admin_Test_Response.reply)
  return _impl_.reply_.Release();
}
inline void Admin_Test_Response::set_allocated_reply(std::string* reply) {
  if (reply != nullptr) {
    
  } else {
    
  }
  _impl_.reply_.SetAllocated(reply, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_.IsDefault()) {
    _impl_.reply_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:muas.Admin_Test_Response.reply)
}

// -------------------------------------------------------------------

// WUAS_QuadRaster_Request

// .muas.Position nw_coord = 1;
inline bool WUAS_QuadRaster_Request::_internal_has_nw_coord() const {
  return this != internal_default_instance() && _impl_.nw_coord_ != nullptr;
}
inline bool WUAS_QuadRaster_Request::has_nw_coord() const {
  return _internal_has_nw_coord();
}
inline void WUAS_QuadRaster_Request::clear_nw_coord() {
  if (GetArenaForAllocation() == nullptr && _impl_.nw_coord_ != nullptr) {
    delete _impl_.nw_coord_;
  }
  _impl_.nw_coord_ = nullptr;
}
inline const ::muas::Position& WUAS_QuadRaster_Request::_internal_nw_coord() const {
  const ::muas::Position* p = _impl_.nw_coord_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::Position&>(
      ::muas::_Position_default_instance_);
}
inline const ::muas::Position& WUAS_QuadRaster_Request::nw_coord() const {
  // @@protoc_insertion_point(field_get:muas.WUAS_QuadRaster_Request.nw_coord)
  return _internal_nw_coord();
}
inline void WUAS_QuadRaster_Request::unsafe_arena_set_allocated_nw_coord(
    ::muas::Position* nw_coord) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nw_coord_);
  }
  _impl_.nw_coord_ = nw_coord;
  if (nw_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.WUAS_QuadRaster_Request.nw_coord)
}
inline ::muas::Position* WUAS_QuadRaster_Request::release_nw_coord() {
  
  ::muas::Position* temp = _impl_.nw_coord_;
  _impl_.nw_coord_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::Position* WUAS_QuadRaster_Request::unsafe_arena_release_nw_coord() {
  // @@protoc_insertion_point(field_release:muas.WUAS_QuadRaster_Request.nw_coord)
  
  ::muas::Position* temp = _impl_.nw_coord_;
  _impl_.nw_coord_ = nullptr;
  return temp;
}
inline ::muas::Position* WUAS_QuadRaster_Request::_internal_mutable_nw_coord() {
  
  if (_impl_.nw_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::Position>(GetArenaForAllocation());
    _impl_.nw_coord_ = p;
  }
  return _impl_.nw_coord_;
}
inline ::muas::Position* WUAS_QuadRaster_Request::mutable_nw_coord() {
  ::muas::Position* _msg = _internal_mutable_nw_coord();
  // @@protoc_insertion_point(field_mutable:muas.WUAS_QuadRaster_Request.nw_coord)
  return _msg;
}
inline void WUAS_QuadRaster_Request::set_allocated_nw_coord(::muas::Position* nw_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nw_coord_;
  }
  if (nw_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nw_coord);
    if (message_arena != submessage_arena) {
      nw_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nw_coord, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nw_coord_ = nw_coord;
  // @@protoc_insertion_point(field_set_allocated:muas.WUAS_QuadRaster_Request.nw_coord)
}

// .muas.Position se_coord = 2;
inline bool WUAS_QuadRaster_Request::_internal_has_se_coord() const {
  return this != internal_default_instance() && _impl_.se_coord_ != nullptr;
}
inline bool WUAS_QuadRaster_Request::has_se_coord() const {
  return _internal_has_se_coord();
}
inline void WUAS_QuadRaster_Request::clear_se_coord() {
  if (GetArenaForAllocation() == nullptr && _impl_.se_coord_ != nullptr) {
    delete _impl_.se_coord_;
  }
  _impl_.se_coord_ = nullptr;
}
inline const ::muas::Position& WUAS_QuadRaster_Request::_internal_se_coord() const {
  const ::muas::Position* p = _impl_.se_coord_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::Position&>(
      ::muas::_Position_default_instance_);
}
inline const ::muas::Position& WUAS_QuadRaster_Request::se_coord() const {
  // @@protoc_insertion_point(field_get:muas.WUAS_QuadRaster_Request.se_coord)
  return _internal_se_coord();
}
inline void WUAS_QuadRaster_Request::unsafe_arena_set_allocated_se_coord(
    ::muas::Position* se_coord) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.se_coord_);
  }
  _impl_.se_coord_ = se_coord;
  if (se_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.WUAS_QuadRaster_Request.se_coord)
}
inline ::muas::Position* WUAS_QuadRaster_Request::release_se_coord() {
  
  ::muas::Position* temp = _impl_.se_coord_;
  _impl_.se_coord_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::Position* WUAS_QuadRaster_Request::unsafe_arena_release_se_coord() {
  // @@protoc_insertion_point(field_release:muas.WUAS_QuadRaster_Request.se_coord)
  
  ::muas::Position* temp = _impl_.se_coord_;
  _impl_.se_coord_ = nullptr;
  return temp;
}
inline ::muas::Position* WUAS_QuadRaster_Request::_internal_mutable_se_coord() {
  
  if (_impl_.se_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::Position>(GetArenaForAllocation());
    _impl_.se_coord_ = p;
  }
  return _impl_.se_coord_;
}
inline ::muas::Position* WUAS_QuadRaster_Request::mutable_se_coord() {
  ::muas::Position* _msg = _internal_mutable_se_coord();
  // @@protoc_insertion_point(field_mutable:muas.WUAS_QuadRaster_Request.se_coord)
  return _msg;
}
inline void WUAS_QuadRaster_Request::set_allocated_se_coord(::muas::Position* se_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.se_coord_;
  }
  if (se_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(se_coord);
    if (message_arena != submessage_arena) {
      se_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, se_coord, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.se_coord_ = se_coord;
  // @@protoc_insertion_point(field_set_allocated:muas.WUAS_QuadRaster_Request.se_coord)
}

// float alt = 3;
inline void WUAS_QuadRaster_Request::clear_alt() {
  _impl_.alt_ = 0;
}
inline float WUAS_QuadRaster_Request::_internal_alt() const {
  return _impl_.alt_;
}
inline float WUAS_QuadRaster_Request::alt() const {
  // @@protoc_insertion_point(field_get:muas.WUAS_QuadRaster_Request.alt)
  return _internal_alt();
}
inline void WUAS_QuadRaster_Request::_internal_set_alt(float value) {
  
  _impl_.alt_ = value;
}
inline void WUAS_QuadRaster_Request::set_alt(float value) {
  _internal_set_alt(value);
  // @@protoc_insertion_point(field_set:muas.WUAS_QuadRaster_Request.alt)
}

// int32 passes = 4;
inline void WUAS_QuadRaster_Request::clear_passes() {
  _impl_.passes_ = 0;
}
inline int32_t WUAS_QuadRaster_Request::_internal_passes() const {
  return _impl_.passes_;
}
inline int32_t WUAS_QuadRaster_Request::passes() const {
  // @@protoc_insertion_point(field_get:muas.WUAS_QuadRaster_Request.passes)
  return _internal_passes();
}
inline void WUAS_QuadRaster_Request::_internal_set_passes(int32_t value) {
  
  _impl_.passes_ = value;
}
inline void WUAS_QuadRaster_Request::set_passes(int32_t value) {
  _internal_set_passes(value);
  // @@protoc_insertion_point(field_set:muas.WUAS_QuadRaster_Request.passes)
}

// -------------------------------------------------------------------

// WUAS_QuadRaster_Response

// .muas.NDNSF_Response response = 1;
inline bool WUAS_QuadRaster_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool WUAS_QuadRaster_Response::has_response() const {
  return _internal_has_response();
}
inline void WUAS_QuadRaster_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& WUAS_QuadRaster_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& WUAS_QuadRaster_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.WUAS_QuadRaster_Response.response)
  return _internal_response();
}
inline void WUAS_QuadRaster_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.WUAS_QuadRaster_Response.response)
}
inline ::muas::NDNSF_Response* WUAS_QuadRaster_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* WUAS_QuadRaster_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.WUAS_QuadRaster_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* WUAS_QuadRaster_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* WUAS_QuadRaster_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.WUAS_QuadRaster_Response.response)
  return _msg;
}
inline void WUAS_QuadRaster_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.WUAS_QuadRaster_Response.response)
}

// -------------------------------------------------------------------

// IUAS_PointOrbit_Request

// .muas.Position target = 1;
inline bool IUAS_PointOrbit_Request::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool IUAS_PointOrbit_Request::has_target() const {
  return _internal_has_target();
}
inline void IUAS_PointOrbit_Request::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::muas::Position& IUAS_PointOrbit_Request::_internal_target() const {
  const ::muas::Position* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::Position&>(
      ::muas::_Position_default_instance_);
}
inline const ::muas::Position& IUAS_PointOrbit_Request::target() const {
  // @@protoc_insertion_point(field_get:muas.IUAS_PointOrbit_Request.target)
  return _internal_target();
}
inline void IUAS_PointOrbit_Request::unsafe_arena_set_allocated_target(
    ::muas::Position* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.IUAS_PointOrbit_Request.target)
}
inline ::muas::Position* IUAS_PointOrbit_Request::release_target() {
  
  ::muas::Position* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::Position* IUAS_PointOrbit_Request::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:muas.IUAS_PointOrbit_Request.target)
  
  ::muas::Position* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::muas::Position* IUAS_PointOrbit_Request::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::Position>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::muas::Position* IUAS_PointOrbit_Request::mutable_target() {
  ::muas::Position* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:muas.IUAS_PointOrbit_Request.target)
  return _msg;
}
inline void IUAS_PointOrbit_Request::set_allocated_target(::muas::Position* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:muas.IUAS_PointOrbit_Request.target)
}

// -------------------------------------------------------------------

// IUAS_PointOrbit_Response

// .muas.NDNSF_Response response = 1;
inline bool IUAS_PointOrbit_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool IUAS_PointOrbit_Response::has_response() const {
  return _internal_has_response();
}
inline void IUAS_PointOrbit_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& IUAS_PointOrbit_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& IUAS_PointOrbit_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.IUAS_PointOrbit_Response.response)
  return _internal_response();
}
inline void IUAS_PointOrbit_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.IUAS_PointOrbit_Response.response)
}
inline ::muas::NDNSF_Response* IUAS_PointOrbit_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* IUAS_PointOrbit_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.IUAS_PointOrbit_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* IUAS_PointOrbit_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* IUAS_PointOrbit_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.IUAS_PointOrbit_Response.response)
  return _msg;
}
inline void IUAS_PointOrbit_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.IUAS_PointOrbit_Response.response)
}

// -------------------------------------------------------------------

// IUAS_PointHover_Request

// .muas.Position pos = 1;
inline bool IUAS_PointHover_Request::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool IUAS_PointHover_Request::has_pos() const {
  return _internal_has_pos();
}
inline void IUAS_PointHover_Request::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::muas::Position& IUAS_PointHover_Request::_internal_pos() const {
  const ::muas::Position* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::Position&>(
      ::muas::_Position_default_instance_);
}
inline const ::muas::Position& IUAS_PointHover_Request::pos() const {
  // @@protoc_insertion_point(field_get:muas.IUAS_PointHover_Request.pos)
  return _internal_pos();
}
inline void IUAS_PointHover_Request::unsafe_arena_set_allocated_pos(
    ::muas::Position* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.IUAS_PointHover_Request.pos)
}
inline ::muas::Position* IUAS_PointHover_Request::release_pos() {
  
  ::muas::Position* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::Position* IUAS_PointHover_Request::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:muas.IUAS_PointHover_Request.pos)
  
  ::muas::Position* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::muas::Position* IUAS_PointHover_Request::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::Position>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::muas::Position* IUAS_PointHover_Request::mutable_pos() {
  ::muas::Position* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:muas.IUAS_PointHover_Request.pos)
  return _msg;
}
inline void IUAS_PointHover_Request::set_allocated_pos(::muas::Position* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:muas.IUAS_PointHover_Request.pos)
}

// -------------------------------------------------------------------

// IUAS_PointHover_Response

// .muas.NDNSF_Response response = 1;
inline bool IUAS_PointHover_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool IUAS_PointHover_Response::has_response() const {
  return _internal_has_response();
}
inline void IUAS_PointHover_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& IUAS_PointHover_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& IUAS_PointHover_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.IUAS_PointHover_Response.response)
  return _internal_response();
}
inline void IUAS_PointHover_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.IUAS_PointHover_Response.response)
}
inline ::muas::NDNSF_Response* IUAS_PointHover_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* IUAS_PointHover_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.IUAS_PointHover_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* IUAS_PointHover_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* IUAS_PointHover_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.IUAS_PointHover_Response.response)
  return _msg;
}
inline void IUAS_PointHover_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.IUAS_PointHover_Response.response)
}

// -------------------------------------------------------------------

// Mission_GetMissionInfo_Request

// -------------------------------------------------------------------

// Mission_GetMissionInfo_Response

// .muas.NDNSF_Response response = 1;
inline bool Mission_GetMissionInfo_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Mission_GetMissionInfo_Response::has_response() const {
  return _internal_has_response();
}
inline void Mission_GetMissionInfo_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& Mission_GetMissionInfo_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& Mission_GetMissionInfo_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.Mission_GetMissionInfo_Response.response)
  return _internal_response();
}
inline void Mission_GetMissionInfo_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Mission_GetMissionInfo_Response.response)
}
inline ::muas::NDNSF_Response* Mission_GetMissionInfo_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* Mission_GetMissionInfo_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.Mission_GetMissionInfo_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* Mission_GetMissionInfo_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* Mission_GetMissionInfo_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.Mission_GetMissionInfo_Response.response)
  return _msg;
}
inline void Mission_GetMissionInfo_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.Mission_GetMissionInfo_Response.response)
}

// .muas.MissionInfo info = 2;
inline bool Mission_GetMissionInfo_Response::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool Mission_GetMissionInfo_Response::has_info() const {
  return _internal_has_info();
}
inline void Mission_GetMissionInfo_Response::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::muas::MissionInfo& Mission_GetMissionInfo_Response::_internal_info() const {
  const ::muas::MissionInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::MissionInfo&>(
      ::muas::_MissionInfo_default_instance_);
}
inline const ::muas::MissionInfo& Mission_GetMissionInfo_Response::info() const {
  // @@protoc_insertion_point(field_get:muas.Mission_GetMissionInfo_Response.info)
  return _internal_info();
}
inline void Mission_GetMissionInfo_Response::unsafe_arena_set_allocated_info(
    ::muas::MissionInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Mission_GetMissionInfo_Response.info)
}
inline ::muas::MissionInfo* Mission_GetMissionInfo_Response::release_info() {
  
  ::muas::MissionInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::MissionInfo* Mission_GetMissionInfo_Response::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:muas.Mission_GetMissionInfo_Response.info)
  
  ::muas::MissionInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::muas::MissionInfo* Mission_GetMissionInfo_Response::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::MissionInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::muas::MissionInfo* Mission_GetMissionInfo_Response::mutable_info() {
  ::muas::MissionInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:muas.Mission_GetMissionInfo_Response.info)
  return _msg;
}
inline void Mission_GetMissionInfo_Response::set_allocated_info(::muas::MissionInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:muas.Mission_GetMissionInfo_Response.info)
}

// -------------------------------------------------------------------

// Mission_GetItem_Request

// int32 idx = 1;
inline void Mission_GetItem_Request::clear_idx() {
  _impl_.idx_ = 0;
}
inline int32_t Mission_GetItem_Request::_internal_idx() const {
  return _impl_.idx_;
}
inline int32_t Mission_GetItem_Request::idx() const {
  // @@protoc_insertion_point(field_get:muas.Mission_GetItem_Request.idx)
  return _internal_idx();
}
inline void Mission_GetItem_Request::_internal_set_idx(int32_t value) {
  
  _impl_.idx_ = value;
}
inline void Mission_GetItem_Request::set_idx(int32_t value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:muas.Mission_GetItem_Request.idx)
}

// -------------------------------------------------------------------

// Mission_GetItem_Response

// .muas.NDNSF_Response response = 1;
inline bool Mission_GetItem_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Mission_GetItem_Response::has_response() const {
  return _internal_has_response();
}
inline void Mission_GetItem_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& Mission_GetItem_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& Mission_GetItem_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.Mission_GetItem_Response.response)
  return _internal_response();
}
inline void Mission_GetItem_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Mission_GetItem_Response.response)
}
inline ::muas::NDNSF_Response* Mission_GetItem_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* Mission_GetItem_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.Mission_GetItem_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* Mission_GetItem_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* Mission_GetItem_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.Mission_GetItem_Response.response)
  return _msg;
}
inline void Mission_GetItem_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.Mission_GetItem_Response.response)
}

// .muas.MissionItem item = 2;
inline bool Mission_GetItem_Response::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool Mission_GetItem_Response::has_item() const {
  return _internal_has_item();
}
inline void Mission_GetItem_Response::clear_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
    delete _impl_.item_;
  }
  _impl_.item_ = nullptr;
}
inline const ::muas::MissionItem& Mission_GetItem_Response::_internal_item() const {
  const ::muas::MissionItem* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::MissionItem&>(
      ::muas::_MissionItem_default_instance_);
}
inline const ::muas::MissionItem& Mission_GetItem_Response::item() const {
  // @@protoc_insertion_point(field_get:muas.Mission_GetItem_Response.item)
  return _internal_item();
}
inline void Mission_GetItem_Response::unsafe_arena_set_allocated_item(
    ::muas::MissionItem* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Mission_GetItem_Response.item)
}
inline ::muas::MissionItem* Mission_GetItem_Response::release_item() {
  
  ::muas::MissionItem* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::MissionItem* Mission_GetItem_Response::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:muas.Mission_GetItem_Response.item)
  
  ::muas::MissionItem* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::muas::MissionItem* Mission_GetItem_Response::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::MissionItem>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::muas::MissionItem* Mission_GetItem_Response::mutable_item() {
  ::muas::MissionItem* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:muas.Mission_GetItem_Response.item)
  return _msg;
}
inline void Mission_GetItem_Response::set_allocated_item(::muas::MissionItem* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:muas.Mission_GetItem_Response.item)
}

// -------------------------------------------------------------------

// Mission_SetItem_Request

// int32 idx = 1;
inline void Mission_SetItem_Request::clear_idx() {
  _impl_.idx_ = 0;
}
inline int32_t Mission_SetItem_Request::_internal_idx() const {
  return _impl_.idx_;
}
inline int32_t Mission_SetItem_Request::idx() const {
  // @@protoc_insertion_point(field_get:muas.Mission_SetItem_Request.idx)
  return _internal_idx();
}
inline void Mission_SetItem_Request::_internal_set_idx(int32_t value) {
  
  _impl_.idx_ = value;
}
inline void Mission_SetItem_Request::set_idx(int32_t value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:muas.Mission_SetItem_Request.idx)
}

// .muas.MissionItem item = 2;
inline bool Mission_SetItem_Request::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool Mission_SetItem_Request::has_item() const {
  return _internal_has_item();
}
inline void Mission_SetItem_Request::clear_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
    delete _impl_.item_;
  }
  _impl_.item_ = nullptr;
}
inline const ::muas::MissionItem& Mission_SetItem_Request::_internal_item() const {
  const ::muas::MissionItem* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::MissionItem&>(
      ::muas::_MissionItem_default_instance_);
}
inline const ::muas::MissionItem& Mission_SetItem_Request::item() const {
  // @@protoc_insertion_point(field_get:muas.Mission_SetItem_Request.item)
  return _internal_item();
}
inline void Mission_SetItem_Request::unsafe_arena_set_allocated_item(
    ::muas::MissionItem* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Mission_SetItem_Request.item)
}
inline ::muas::MissionItem* Mission_SetItem_Request::release_item() {
  
  ::muas::MissionItem* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::MissionItem* Mission_SetItem_Request::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:muas.Mission_SetItem_Request.item)
  
  ::muas::MissionItem* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::muas::MissionItem* Mission_SetItem_Request::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::MissionItem>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::muas::MissionItem* Mission_SetItem_Request::mutable_item() {
  ::muas::MissionItem* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:muas.Mission_SetItem_Request.item)
  return _msg;
}
inline void Mission_SetItem_Request::set_allocated_item(::muas::MissionItem* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:muas.Mission_SetItem_Request.item)
}

// -------------------------------------------------------------------

// Mission_SetItem_Response

// .muas.NDNSF_Response response = 1;
inline bool Mission_SetItem_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Mission_SetItem_Response::has_response() const {
  return _internal_has_response();
}
inline void Mission_SetItem_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& Mission_SetItem_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& Mission_SetItem_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.Mission_SetItem_Response.response)
  return _internal_response();
}
inline void Mission_SetItem_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Mission_SetItem_Response.response)
}
inline ::muas::NDNSF_Response* Mission_SetItem_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* Mission_SetItem_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.Mission_SetItem_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* Mission_SetItem_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* Mission_SetItem_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.Mission_SetItem_Response.response)
  return _msg;
}
inline void Mission_SetItem_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.Mission_SetItem_Response.response)
}

// -------------------------------------------------------------------

// Mission_Clear_Request

// -------------------------------------------------------------------

// Mission_Clear_Response

// .muas.NDNSF_Response response = 1;
inline bool Mission_Clear_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Mission_Clear_Response::has_response() const {
  return _internal_has_response();
}
inline void Mission_Clear_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& Mission_Clear_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& Mission_Clear_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.Mission_Clear_Response.response)
  return _internal_response();
}
inline void Mission_Clear_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Mission_Clear_Response.response)
}
inline ::muas::NDNSF_Response* Mission_Clear_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* Mission_Clear_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.Mission_Clear_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* Mission_Clear_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* Mission_Clear_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.Mission_Clear_Response.response)
  return _msg;
}
inline void Mission_Clear_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.Mission_Clear_Response.response)
}

// -------------------------------------------------------------------

// Mission_Start_Request

// -------------------------------------------------------------------

// Mission_Start_Response

// .muas.NDNSF_Response response = 1;
inline bool Mission_Start_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Mission_Start_Response::has_response() const {
  return _internal_has_response();
}
inline void Mission_Start_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& Mission_Start_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& Mission_Start_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.Mission_Start_Response.response)
  return _internal_response();
}
inline void Mission_Start_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Mission_Start_Response.response)
}
inline ::muas::NDNSF_Response* Mission_Start_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* Mission_Start_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.Mission_Start_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* Mission_Start_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* Mission_Start_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.Mission_Start_Response.response)
  return _msg;
}
inline void Mission_Start_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.Mission_Start_Response.response)
}

// -------------------------------------------------------------------

// Mission_Pause_Request

// -------------------------------------------------------------------

// Mission_Pause_Response

// .muas.NDNSF_Response response = 1;
inline bool Mission_Pause_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Mission_Pause_Response::has_response() const {
  return _internal_has_response();
}
inline void Mission_Pause_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& Mission_Pause_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& Mission_Pause_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.Mission_Pause_Response.response)
  return _internal_response();
}
inline void Mission_Pause_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Mission_Pause_Response.response)
}
inline ::muas::NDNSF_Response* Mission_Pause_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* Mission_Pause_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.Mission_Pause_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* Mission_Pause_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* Mission_Pause_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.Mission_Pause_Response.response)
  return _msg;
}
inline void Mission_Pause_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.Mission_Pause_Response.response)
}

// -------------------------------------------------------------------

// Mission_Continue_Request

// -------------------------------------------------------------------

// Mission_Continue_Response

// .muas.NDNSF_Response response = 1;
inline bool Mission_Continue_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Mission_Continue_Response::has_response() const {
  return _internal_has_response();
}
inline void Mission_Continue_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& Mission_Continue_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& Mission_Continue_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.Mission_Continue_Response.response)
  return _internal_response();
}
inline void Mission_Continue_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Mission_Continue_Response.response)
}
inline ::muas::NDNSF_Response* Mission_Continue_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* Mission_Continue_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.Mission_Continue_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* Mission_Continue_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* Mission_Continue_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.Mission_Continue_Response.response)
  return _msg;
}
inline void Mission_Continue_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.Mission_Continue_Response.response)
}

// -------------------------------------------------------------------

// Mission_Terminate_Request

// -------------------------------------------------------------------

// Mission_Terminate_Response

// .muas.NDNSF_Response response = 1;
inline bool Mission_Terminate_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Mission_Terminate_Response::has_response() const {
  return _internal_has_response();
}
inline void Mission_Terminate_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& Mission_Terminate_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& Mission_Terminate_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.Mission_Terminate_Response.response)
  return _internal_response();
}
inline void Mission_Terminate_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.Mission_Terminate_Response.response)
}
inline ::muas::NDNSF_Response* Mission_Terminate_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* Mission_Terminate_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.Mission_Terminate_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* Mission_Terminate_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* Mission_Terminate_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.Mission_Terminate_Response.response)
  return _msg;
}
inline void Mission_Terminate_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.Mission_Terminate_Response.response)
}

// -------------------------------------------------------------------

// FlightCtrl_SwitchMode_Request

// .muas.FlightCtrl_SwitchMode_Request.FlightMode mode = 1;
inline void FlightCtrl_SwitchMode_Request::clear_mode() {
  _impl_.mode_ = 0;
}
inline ::muas::FlightCtrl_SwitchMode_Request_FlightMode FlightCtrl_SwitchMode_Request::_internal_mode() const {
  return static_cast< ::muas::FlightCtrl_SwitchMode_Request_FlightMode >(_impl_.mode_);
}
inline ::muas::FlightCtrl_SwitchMode_Request_FlightMode FlightCtrl_SwitchMode_Request::mode() const {
  // @@protoc_insertion_point(field_get:muas.FlightCtrl_SwitchMode_Request.mode)
  return _internal_mode();
}
inline void FlightCtrl_SwitchMode_Request::_internal_set_mode(::muas::FlightCtrl_SwitchMode_Request_FlightMode value) {
  
  _impl_.mode_ = value;
}
inline void FlightCtrl_SwitchMode_Request::set_mode(::muas::FlightCtrl_SwitchMode_Request_FlightMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:muas.FlightCtrl_SwitchMode_Request.mode)
}

// -------------------------------------------------------------------

// FlightCtrl_SwitchMode_Response

// .muas.NDNSF_Response response = 1;
inline bool FlightCtrl_SwitchMode_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool FlightCtrl_SwitchMode_Response::has_response() const {
  return _internal_has_response();
}
inline void FlightCtrl_SwitchMode_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& FlightCtrl_SwitchMode_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& FlightCtrl_SwitchMode_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.FlightCtrl_SwitchMode_Response.response)
  return _internal_response();
}
inline void FlightCtrl_SwitchMode_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.FlightCtrl_SwitchMode_Response.response)
}
inline ::muas::NDNSF_Response* FlightCtrl_SwitchMode_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* FlightCtrl_SwitchMode_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.FlightCtrl_SwitchMode_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* FlightCtrl_SwitchMode_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* FlightCtrl_SwitchMode_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.FlightCtrl_SwitchMode_Response.response)
  return _msg;
}
inline void FlightCtrl_SwitchMode_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.FlightCtrl_SwitchMode_Response.response)
}

// -------------------------------------------------------------------

// FlightCtrl_Takeoff_Request

// -------------------------------------------------------------------

// FlightCtrl_Takeoff_Response

// .muas.NDNSF_Response response = 1;
inline bool FlightCtrl_Takeoff_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool FlightCtrl_Takeoff_Response::has_response() const {
  return _internal_has_response();
}
inline void FlightCtrl_Takeoff_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& FlightCtrl_Takeoff_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& FlightCtrl_Takeoff_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.FlightCtrl_Takeoff_Response.response)
  return _internal_response();
}
inline void FlightCtrl_Takeoff_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.FlightCtrl_Takeoff_Response.response)
}
inline ::muas::NDNSF_Response* FlightCtrl_Takeoff_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* FlightCtrl_Takeoff_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.FlightCtrl_Takeoff_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* FlightCtrl_Takeoff_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* FlightCtrl_Takeoff_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.FlightCtrl_Takeoff_Response.response)
  return _msg;
}
inline void FlightCtrl_Takeoff_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.FlightCtrl_Takeoff_Response.response)
}

// -------------------------------------------------------------------

// FlightCtrl_Land_Request

// -------------------------------------------------------------------

// FlightCtrl_Land_Response

// .muas.NDNSF_Response response = 1;
inline bool FlightCtrl_Land_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool FlightCtrl_Land_Response::has_response() const {
  return _internal_has_response();
}
inline void FlightCtrl_Land_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& FlightCtrl_Land_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& FlightCtrl_Land_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.FlightCtrl_Land_Response.response)
  return _internal_response();
}
inline void FlightCtrl_Land_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.FlightCtrl_Land_Response.response)
}
inline ::muas::NDNSF_Response* FlightCtrl_Land_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* FlightCtrl_Land_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.FlightCtrl_Land_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* FlightCtrl_Land_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* FlightCtrl_Land_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.FlightCtrl_Land_Response.response)
  return _msg;
}
inline void FlightCtrl_Land_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.FlightCtrl_Land_Response.response)
}

// -------------------------------------------------------------------

// FlightCtrl_RTL_Request

// -------------------------------------------------------------------

// FlightCtrl_RTL_Response

// .muas.NDNSF_Response response = 1;
inline bool FlightCtrl_RTL_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool FlightCtrl_RTL_Response::has_response() const {
  return _internal_has_response();
}
inline void FlightCtrl_RTL_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& FlightCtrl_RTL_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& FlightCtrl_RTL_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.FlightCtrl_RTL_Response.response)
  return _internal_response();
}
inline void FlightCtrl_RTL_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.FlightCtrl_RTL_Response.response)
}
inline ::muas::NDNSF_Response* FlightCtrl_RTL_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* FlightCtrl_RTL_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.FlightCtrl_RTL_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* FlightCtrl_RTL_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* FlightCtrl_RTL_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.FlightCtrl_RTL_Response.response)
  return _msg;
}
inline void FlightCtrl_RTL_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.FlightCtrl_RTL_Response.response)
}

// -------------------------------------------------------------------

// FlightCtrl_Kill_Request

// -------------------------------------------------------------------

// FlightCtrl_Kill_Response

// .muas.NDNSF_Response response = 1;
inline bool FlightCtrl_Kill_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool FlightCtrl_Kill_Response::has_response() const {
  return _internal_has_response();
}
inline void FlightCtrl_Kill_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& FlightCtrl_Kill_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& FlightCtrl_Kill_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.FlightCtrl_Kill_Response.response)
  return _internal_response();
}
inline void FlightCtrl_Kill_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.FlightCtrl_Kill_Response.response)
}
inline ::muas::NDNSF_Response* FlightCtrl_Kill_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* FlightCtrl_Kill_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.FlightCtrl_Kill_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* FlightCtrl_Kill_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* FlightCtrl_Kill_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.FlightCtrl_Kill_Response.response)
  return _msg;
}
inline void FlightCtrl_Kill_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.FlightCtrl_Kill_Response.response)
}

// -------------------------------------------------------------------

// FlightCtrl_SetSpeed_Request

// int32 speed = 1;
inline void FlightCtrl_SetSpeed_Request::clear_speed() {
  _impl_.speed_ = 0;
}
inline int32_t FlightCtrl_SetSpeed_Request::_internal_speed() const {
  return _impl_.speed_;
}
inline int32_t FlightCtrl_SetSpeed_Request::speed() const {
  // @@protoc_insertion_point(field_get:muas.FlightCtrl_SetSpeed_Request.speed)
  return _internal_speed();
}
inline void FlightCtrl_SetSpeed_Request::_internal_set_speed(int32_t value) {
  
  _impl_.speed_ = value;
}
inline void FlightCtrl_SetSpeed_Request::set_speed(int32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:muas.FlightCtrl_SetSpeed_Request.speed)
}

// -------------------------------------------------------------------

// FlightCtrl_SetSpeed_Response

// .muas.NDNSF_Response response = 1;
inline bool FlightCtrl_SetSpeed_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool FlightCtrl_SetSpeed_Response::has_response() const {
  return _internal_has_response();
}
inline void FlightCtrl_SetSpeed_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& FlightCtrl_SetSpeed_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& FlightCtrl_SetSpeed_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.FlightCtrl_SetSpeed_Response.response)
  return _internal_response();
}
inline void FlightCtrl_SetSpeed_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.FlightCtrl_SetSpeed_Response.response)
}
inline ::muas::NDNSF_Response* FlightCtrl_SetSpeed_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* FlightCtrl_SetSpeed_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.FlightCtrl_SetSpeed_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* FlightCtrl_SetSpeed_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* FlightCtrl_SetSpeed_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.FlightCtrl_SetSpeed_Response.response)
  return _msg;
}
inline void FlightCtrl_SetSpeed_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.FlightCtrl_SetSpeed_Response.response)
}

// -------------------------------------------------------------------

// FlightCtrl_Reposition_Request

// .muas.Position pos = 1;
inline bool FlightCtrl_Reposition_Request::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool FlightCtrl_Reposition_Request::has_pos() const {
  return _internal_has_pos();
}
inline void FlightCtrl_Reposition_Request::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::muas::Position& FlightCtrl_Reposition_Request::_internal_pos() const {
  const ::muas::Position* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::Position&>(
      ::muas::_Position_default_instance_);
}
inline const ::muas::Position& FlightCtrl_Reposition_Request::pos() const {
  // @@protoc_insertion_point(field_get:muas.FlightCtrl_Reposition_Request.pos)
  return _internal_pos();
}
inline void FlightCtrl_Reposition_Request::unsafe_arena_set_allocated_pos(
    ::muas::Position* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.FlightCtrl_Reposition_Request.pos)
}
inline ::muas::Position* FlightCtrl_Reposition_Request::release_pos() {
  
  ::muas::Position* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::Position* FlightCtrl_Reposition_Request::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:muas.FlightCtrl_Reposition_Request.pos)
  
  ::muas::Position* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::muas::Position* FlightCtrl_Reposition_Request::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::Position>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::muas::Position* FlightCtrl_Reposition_Request::mutable_pos() {
  ::muas::Position* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:muas.FlightCtrl_Reposition_Request.pos)
  return _msg;
}
inline void FlightCtrl_Reposition_Request::set_allocated_pos(::muas::Position* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:muas.FlightCtrl_Reposition_Request.pos)
}

// -------------------------------------------------------------------

// FlightCtrl_Reposition_Response

// .muas.NDNSF_Response response = 1;
inline bool FlightCtrl_Reposition_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool FlightCtrl_Reposition_Response::has_response() const {
  return _internal_has_response();
}
inline void FlightCtrl_Reposition_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& FlightCtrl_Reposition_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& FlightCtrl_Reposition_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.FlightCtrl_Reposition_Response.response)
  return _internal_response();
}
inline void FlightCtrl_Reposition_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.FlightCtrl_Reposition_Response.response)
}
inline ::muas::NDNSF_Response* FlightCtrl_Reposition_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* FlightCtrl_Reposition_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.FlightCtrl_Reposition_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* FlightCtrl_Reposition_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* FlightCtrl_Reposition_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.FlightCtrl_Reposition_Response.response)
  return _msg;
}
inline void FlightCtrl_Reposition_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.FlightCtrl_Reposition_Response.response)
}

// -------------------------------------------------------------------

// MAVLink_Generic_Request

// -------------------------------------------------------------------

// MAVLink_Generic_Response

// .muas.NDNSF_Response response = 1;
inline bool MAVLink_Generic_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool MAVLink_Generic_Response::has_response() const {
  return _internal_has_response();
}
inline void MAVLink_Generic_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& MAVLink_Generic_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& MAVLink_Generic_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.MAVLink_Generic_Response.response)
  return _internal_response();
}
inline void MAVLink_Generic_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.MAVLink_Generic_Response.response)
}
inline ::muas::NDNSF_Response* MAVLink_Generic_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* MAVLink_Generic_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.MAVLink_Generic_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* MAVLink_Generic_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* MAVLink_Generic_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.MAVLink_Generic_Response.response)
  return _msg;
}
inline void MAVLink_Generic_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.MAVLink_Generic_Response.response)
}

// optional string mav_response = 2;
inline bool MAVLink_Generic_Response::_internal_has_mav_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MAVLink_Generic_Response::has_mav_response() const {
  return _internal_has_mav_response();
}
inline void MAVLink_Generic_Response::clear_mav_response() {
  _impl_.mav_response_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MAVLink_Generic_Response::mav_response() const {
  // @@protoc_insertion_point(field_get:muas.MAVLink_Generic_Response.mav_response)
  return _internal_mav_response();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MAVLink_Generic_Response::set_mav_response(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.mav_response_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:muas.MAVLink_Generic_Response.mav_response)
}
inline std::string* MAVLink_Generic_Response::mutable_mav_response() {
  std::string* _s = _internal_mutable_mav_response();
  // @@protoc_insertion_point(field_mutable:muas.MAVLink_Generic_Response.mav_response)
  return _s;
}
inline const std::string& MAVLink_Generic_Response::_internal_mav_response() const {
  return _impl_.mav_response_.Get();
}
inline void MAVLink_Generic_Response::_internal_set_mav_response(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mav_response_.Set(value, GetArenaForAllocation());
}
inline std::string* MAVLink_Generic_Response::_internal_mutable_mav_response() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mav_response_.Mutable(GetArenaForAllocation());
}
inline std::string* MAVLink_Generic_Response::release_mav_response() {
  // @@protoc_insertion_point(field_release:muas.MAVLink_Generic_Response.mav_response)
  if (!_internal_has_mav_response()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.mav_response_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mav_response_.IsDefault()) {
    _impl_.mav_response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MAVLink_Generic_Response::set_allocated_mav_response(std::string* mav_response) {
  if (mav_response != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mav_response_.SetAllocated(mav_response, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mav_response_.IsDefault()) {
    _impl_.mav_response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:muas.MAVLink_Generic_Response.mav_response)
}

// -------------------------------------------------------------------

// SensorCtrl_GetSensorInfo_Request

// -------------------------------------------------------------------

// SensorCtrl_GetSensorInfo_Response

// .muas.NDNSF_Response response = 1;
inline bool SensorCtrl_GetSensorInfo_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool SensorCtrl_GetSensorInfo_Response::has_response() const {
  return _internal_has_response();
}
inline void SensorCtrl_GetSensorInfo_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& SensorCtrl_GetSensorInfo_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& SensorCtrl_GetSensorInfo_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.SensorCtrl_GetSensorInfo_Response.response)
  return _internal_response();
}
inline void SensorCtrl_GetSensorInfo_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.SensorCtrl_GetSensorInfo_Response.response)
}
inline ::muas::NDNSF_Response* SensorCtrl_GetSensorInfo_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* SensorCtrl_GetSensorInfo_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.SensorCtrl_GetSensorInfo_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* SensorCtrl_GetSensorInfo_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* SensorCtrl_GetSensorInfo_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.SensorCtrl_GetSensorInfo_Response.response)
  return _msg;
}
inline void SensorCtrl_GetSensorInfo_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.SensorCtrl_GetSensorInfo_Response.response)
}

// repeated .muas.Sensor sensors = 2;
inline int SensorCtrl_GetSensorInfo_Response::_internal_sensors_size() const {
  return _impl_.sensors_.size();
}
inline int SensorCtrl_GetSensorInfo_Response::sensors_size() const {
  return _internal_sensors_size();
}
inline void SensorCtrl_GetSensorInfo_Response::clear_sensors() {
  _impl_.sensors_.Clear();
}
inline ::muas::Sensor* SensorCtrl_GetSensorInfo_Response::mutable_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:muas.SensorCtrl_GetSensorInfo_Response.sensors)
  return _impl_.sensors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::muas::Sensor >*
SensorCtrl_GetSensorInfo_Response::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_list:muas.SensorCtrl_GetSensorInfo_Response.sensors)
  return &_impl_.sensors_;
}
inline const ::muas::Sensor& SensorCtrl_GetSensorInfo_Response::_internal_sensors(int index) const {
  return _impl_.sensors_.Get(index);
}
inline const ::muas::Sensor& SensorCtrl_GetSensorInfo_Response::sensors(int index) const {
  // @@protoc_insertion_point(field_get:muas.SensorCtrl_GetSensorInfo_Response.sensors)
  return _internal_sensors(index);
}
inline ::muas::Sensor* SensorCtrl_GetSensorInfo_Response::_internal_add_sensors() {
  return _impl_.sensors_.Add();
}
inline ::muas::Sensor* SensorCtrl_GetSensorInfo_Response::add_sensors() {
  ::muas::Sensor* _add = _internal_add_sensors();
  // @@protoc_insertion_point(field_add:muas.SensorCtrl_GetSensorInfo_Response.sensors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::muas::Sensor >&
SensorCtrl_GetSensorInfo_Response::sensors() const {
  // @@protoc_insertion_point(field_list:muas.SensorCtrl_GetSensorInfo_Response.sensors)
  return _impl_.sensors_;
}

// -------------------------------------------------------------------

// SensorCtrl_CaptureSingle_Request

// -------------------------------------------------------------------

// SensorCtrl_CaptureSingle_Response

// .muas.NDNSF_Response response = 1;
inline bool SensorCtrl_CaptureSingle_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool SensorCtrl_CaptureSingle_Response::has_response() const {
  return _internal_has_response();
}
inline void SensorCtrl_CaptureSingle_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& SensorCtrl_CaptureSingle_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& SensorCtrl_CaptureSingle_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.SensorCtrl_CaptureSingle_Response.response)
  return _internal_response();
}
inline void SensorCtrl_CaptureSingle_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.SensorCtrl_CaptureSingle_Response.response)
}
inline ::muas::NDNSF_Response* SensorCtrl_CaptureSingle_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* SensorCtrl_CaptureSingle_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.SensorCtrl_CaptureSingle_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* SensorCtrl_CaptureSingle_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* SensorCtrl_CaptureSingle_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.SensorCtrl_CaptureSingle_Response.response)
  return _msg;
}
inline void SensorCtrl_CaptureSingle_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.SensorCtrl_CaptureSingle_Response.response)
}

// string capture_id = 2;
inline void SensorCtrl_CaptureSingle_Response::clear_capture_id() {
  _impl_.capture_id_.ClearToEmpty();
}
inline const std::string& SensorCtrl_CaptureSingle_Response::capture_id() const {
  // @@protoc_insertion_point(field_get:muas.SensorCtrl_CaptureSingle_Response.capture_id)
  return _internal_capture_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorCtrl_CaptureSingle_Response::set_capture_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.capture_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:muas.SensorCtrl_CaptureSingle_Response.capture_id)
}
inline std::string* SensorCtrl_CaptureSingle_Response::mutable_capture_id() {
  std::string* _s = _internal_mutable_capture_id();
  // @@protoc_insertion_point(field_mutable:muas.SensorCtrl_CaptureSingle_Response.capture_id)
  return _s;
}
inline const std::string& SensorCtrl_CaptureSingle_Response::_internal_capture_id() const {
  return _impl_.capture_id_.Get();
}
inline void SensorCtrl_CaptureSingle_Response::_internal_set_capture_id(const std::string& value) {
  
  _impl_.capture_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorCtrl_CaptureSingle_Response::_internal_mutable_capture_id() {
  
  return _impl_.capture_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorCtrl_CaptureSingle_Response::release_capture_id() {
  // @@protoc_insertion_point(field_release:muas.SensorCtrl_CaptureSingle_Response.capture_id)
  return _impl_.capture_id_.Release();
}
inline void SensorCtrl_CaptureSingle_Response::set_allocated_capture_id(std::string* capture_id) {
  if (capture_id != nullptr) {
    
  } else {
    
  }
  _impl_.capture_id_.SetAllocated(capture_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.capture_id_.IsDefault()) {
    _impl_.capture_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:muas.SensorCtrl_CaptureSingle_Response.capture_id)
}

// -------------------------------------------------------------------

// SensorCtrl_CapturePeriodic_Request

// int32 interval_sec = 1;
inline void SensorCtrl_CapturePeriodic_Request::clear_interval_sec() {
  _impl_.interval_sec_ = 0;
}
inline int32_t SensorCtrl_CapturePeriodic_Request::_internal_interval_sec() const {
  return _impl_.interval_sec_;
}
inline int32_t SensorCtrl_CapturePeriodic_Request::interval_sec() const {
  // @@protoc_insertion_point(field_get:muas.SensorCtrl_CapturePeriodic_Request.interval_sec)
  return _internal_interval_sec();
}
inline void SensorCtrl_CapturePeriodic_Request::_internal_set_interval_sec(int32_t value) {
  
  _impl_.interval_sec_ = value;
}
inline void SensorCtrl_CapturePeriodic_Request::set_interval_sec(int32_t value) {
  _internal_set_interval_sec(value);
  // @@protoc_insertion_point(field_set:muas.SensorCtrl_CapturePeriodic_Request.interval_sec)
}

// -------------------------------------------------------------------

// SensorCtrl_CapturePeriodic_Response

// .muas.NDNSF_Response response = 1;
inline bool SensorCtrl_CapturePeriodic_Response::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool SensorCtrl_CapturePeriodic_Response::has_response() const {
  return _internal_has_response();
}
inline void SensorCtrl_CapturePeriodic_Response::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::muas::NDNSF_Response& SensorCtrl_CapturePeriodic_Response::_internal_response() const {
  const ::muas::NDNSF_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::muas::NDNSF_Response&>(
      ::muas::_NDNSF_Response_default_instance_);
}
inline const ::muas::NDNSF_Response& SensorCtrl_CapturePeriodic_Response::response() const {
  // @@protoc_insertion_point(field_get:muas.SensorCtrl_CapturePeriodic_Response.response)
  return _internal_response();
}
inline void SensorCtrl_CapturePeriodic_Response::unsafe_arena_set_allocated_response(
    ::muas::NDNSF_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:muas.SensorCtrl_CapturePeriodic_Response.response)
}
inline ::muas::NDNSF_Response* SensorCtrl_CapturePeriodic_Response::release_response() {
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::muas::NDNSF_Response* SensorCtrl_CapturePeriodic_Response::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:muas.SensorCtrl_CapturePeriodic_Response.response)
  
  ::muas::NDNSF_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::muas::NDNSF_Response* SensorCtrl_CapturePeriodic_Response::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::muas::NDNSF_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::muas::NDNSF_Response* SensorCtrl_CapturePeriodic_Response::mutable_response() {
  ::muas::NDNSF_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:muas.SensorCtrl_CapturePeriodic_Response.response)
  return _msg;
}
inline void SensorCtrl_CapturePeriodic_Response::set_allocated_response(::muas::NDNSF_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:muas.SensorCtrl_CapturePeriodic_Response.response)
}

// string capture_id = 2;
inline void SensorCtrl_CapturePeriodic_Response::clear_capture_id() {
  _impl_.capture_id_.ClearToEmpty();
}
inline const std::string& SensorCtrl_CapturePeriodic_Response::capture_id() const {
  // @@protoc_insertion_point(field_get:muas.SensorCtrl_CapturePeriodic_Response.capture_id)
  return _internal_capture_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorCtrl_CapturePeriodic_Response::set_capture_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.capture_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:muas.SensorCtrl_CapturePeriodic_Response.capture_id)
}
inline std::string* SensorCtrl_CapturePeriodic_Response::mutable_capture_id() {
  std::string* _s = _internal_mutable_capture_id();
  // @@protoc_insertion_point(field_mutable:muas.SensorCtrl_CapturePeriodic_Response.capture_id)
  return _s;
}
inline const std::string& SensorCtrl_CapturePeriodic_Response::_internal_capture_id() const {
  return _impl_.capture_id_.Get();
}
inline void SensorCtrl_CapturePeriodic_Response::_internal_set_capture_id(const std::string& value) {
  
  _impl_.capture_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorCtrl_CapturePeriodic_Response::_internal_mutable_capture_id() {
  
  return _impl_.capture_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorCtrl_CapturePeriodic_Response::release_capture_id() {
  // @@protoc_insertion_point(field_release:muas.SensorCtrl_CapturePeriodic_Response.capture_id)
  return _impl_.capture_id_.Release();
}
inline void SensorCtrl_CapturePeriodic_Response::set_allocated_capture_id(std::string* capture_id) {
  if (capture_id != nullptr) {
    
  } else {
    
  }
  _impl_.capture_id_.SetAllocated(capture_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.capture_id_.IsDefault()) {
    _impl_.capture_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:muas.SensorCtrl_CapturePeriodic_Response.capture_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace muas

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::muas::MissionItem_Frame> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::muas::MissionItem_Frame>() {
  return ::muas::MissionItem_Frame_descriptor();
}
template <> struct is_proto_enum< ::muas::MissionItem_MAV_CMD> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::muas::MissionItem_MAV_CMD>() {
  return ::muas::MissionItem_MAV_CMD_descriptor();
}
template <> struct is_proto_enum< ::muas::Sensor_SensorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::muas::Sensor_SensorType>() {
  return ::muas::Sensor_SensorType_descriptor();
}
template <> struct is_proto_enum< ::muas::NDNSF_Response_miniMUAS_Code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::muas::NDNSF_Response_miniMUAS_Code>() {
  return ::muas::NDNSF_Response_miniMUAS_Code_descriptor();
}
template <> struct is_proto_enum< ::muas::FlightCtrl_SwitchMode_Request_FlightMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::muas::FlightCtrl_SwitchMode_Request_FlightMode>() {
  return ::muas::FlightCtrl_SwitchMode_Request_FlightMode_descriptor();
}
template <> struct is_proto_enum< ::muas::EntityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::muas::EntityType>() {
  return ::muas::EntityType_descriptor();
}
template <> struct is_proto_enum< ::muas::MAV_MSG> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::muas::MAV_MSG>() {
  return ::muas::MAV_MSG_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
